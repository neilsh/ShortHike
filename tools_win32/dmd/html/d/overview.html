
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/overview.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Digital Mars - The D Programming Language</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Overview" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Tue Jun 13 16:04:02 2006
</div>
</div>

<!-- Generated by Ddoc from overview.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
	<ul>		<li><a href="overview.html">Overview</a></li>

		<li><a href="windows.html">D for Win32</a></li>

		<li><a href="dll.html">Win32 DLLs in D</a></li>

		<li><a href="htomodule.html">C .h to D Modules</a></li>

		<li><a href="faq.html">FAQ</a></li>

		<li><a href="dstyle.html">Style Guide</a></li>

		<li><a href="wc.html">Example: wc</a></li>

		<li><a href="future.html">Future</a></li>

		<li><a href="changelog.html">D Change Log</a></li>

		<li><a href="http://www.digitalmars.com/techtips/index.html">Tech Tips</a></li>

		<li><a href="rationale.html">Rationale</a></li>

		<li><a href="warnings.html">Warnings</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Articles</h2>
	<ul>		<li><a href="memory.html">Memory Management</a></li>

		<li><a href="exception-safe.html">Exception Safety</a></li>

		<li><a href="templates-revisited.html">Templates Revisited</a></li>

		<li><a href="regular-expression.html">Regular Expressions</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Tools</h2>
	<ul>		<li><a href="dcompiler.html">DMD D Compiler</a></li>

		<li><a href="http://dgcc.sourceforge.net/">GDC D Compiler</a></li>

		<li><a href="http://www.digitalmars.com/ctg/optlink.html">Linker</a></li>

		<li><a href="http://www.digitalmars.com/ctg/trace.html">Profiler</a></li>

		<li><a href="code_coverage.html">Code Coverage</a></li>

		<li><a href="rdmd.html">DMD Script Shell</a></li>

		<li><a href="windbg.html">Windows Debugger</a></li>

		<li><a href="htod.html">C .h to D .d</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?EditorSupport">Editors</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?ReferenceForTools">More Tools</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Community</h2>
	<ul>		
		<li><a href="http://www.digitalmars.com/NewsGroup.html">News</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D">Forum</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D.announce">Announcements</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D.learn">Learn</a></li>

		<li><a href="dlinks.html">D links</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Archives</h2>
	<ul>		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/index.html">digitalmars.D</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dtl/index.html">digitalmars.D.dtl</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/announce/index.html">digitalmars.D.announce</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dwt/index.html">digitalmars.D.dwt</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/learn/index.html">digitalmars.D.learn</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/bugs/index.html">digitalmars.D.bugs</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/D/gnu/index.html">D.gnu</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/index.html">Old D</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Appendices</h2>
	<ul>		<li><a href="glossary.html">Glossary</a></li>

		<li><a href="ascii-table.html">Ascii Table</a></li>

		<li><a href="acknowledgements.html">Acknowledgements</a></li>

	</ul>
    </div>


</div>
<div id="content">
  <h1>        Overview</h1>
  
<h2>What is D?</h2>

	<p>D is a general purpose systems and applications programming language.
	It is a higher level language than C++, but retains the ability
	to write high performance code and interface directly with the
	operating system
	<acronym title="Application Programming Interface">API</acronym>'s
	and with hardware.
	D is well suited to writing medium to large scale
	million line programs with teams of developers. D is easy
	to learn, provides many capabilities to aid the programmer,
	and is well suited to aggressive compiler optimization technology.

	<img src="d3.html" border=0 align=right alt="D Man">
	</p>

	<p>D is not a scripting language, nor an interpreted language.
	It doesn't
	come with a <acronym title="Virtual Machine">VM</acronym>,
	a religion, or an overriding
	philosophy. It's a practical language for practical programmers
	who need to get the job done quickly, reliably, and leave behind
	maintainable, easy to understand code.
	</p>

	<p>D is the culmination of decades of experience implementing
	compilers for many diverse languages, and attempting to construct
	large projects using those languages. D draws inspiration from
	those other languages (most especially C++) and tempers it with
	experience and real world practicality.
	</p>



<h2>Why D?</h2>

	<p>Why, indeed. Who needs another programming language?
	</p>

	<p>The software industry has come a long way since the C language was
	invented.
	Many new concepts were added to the language with C++, but backwards
	compatibility with C was maintained, including compatibility with
	nearly all the weaknesses of the original design.
	There have been many attempts to fix those weaknesses, but the
	compatibility issue frustrates it.
	Meanwhile, both C and C++ undergo a constant accretion of new
	features. These new features must be carefully fitted into the
	existing structure without requiring rewriting old code.
	The end result is very complicated - the C standard is nearly
	500 pages, and the C++ standard is about 750 pages!
	C++ is a difficult and costly language to implement,
	resulting in implementation variations that make it frustrating
	to write fully portable C++ code.
	</p>

	<p>C++ programmers tend to program in particular islands of the language,
	i.e. getting very proficient using certain features while avoiding
	other feature sets. While the code is usually portable from compiler
	to compiler, it can be hard to port it from programmer to programmer.
	A great strength of C++ is that it can support many radically
	different styles of programming - but in long term use, the
	overlapping and contradictory styles are a hindrance.
	</p>

	<p>C++ implements things like resizable arrays and string concatenation
	as part of the standard library, not as part of the core language.
	Not being part of the core language has several
	<a href="cppstrings.html">suboptimal consequences</a>.
	</p>

	<p>Can the power and capability of C++ be extracted, redesigned,
	and recast into a language that is simple, orthogonal,
	and practical?
	Can it all be put into a package
	that is easy for compiler
	writers to correctly implement, and
	which enables compilers to efficiently generate aggressively
	optimized code?
	</p>

	<p>Modern compiler technology has progressed to the point where language
	features for the purpose of compensating for primitive compiler
	technology can be omitted. (An 
	example of this would be the 'register' keyword in C, a more
	subtle example is the macro 
	preprocessor in C.)
	We can rely on modern compiler optimization technology to not
	need language features necessary to get acceptable code quality out of
	primitive compilers.
	</p>

<h3>Major Goals of D</h3>

    <ul>	<li>Reduce software development costs by at least 10% by adding
	in proven productivity enhancing features and by adjusting language
	features so that 
	common, time-consuming bugs are eliminated from the start.</li>

	<li>Make it easier to write code that is portable from compiler
	to compiler, machine to machine, and operating system to operating
	system.</li>

	<li>Support multi-paradigm programming, i.e. at a minimum support
	imperative, structured, object oriented, and generic programming
	paradigms.</li>

	<li>Have a short learning curve for programmers comfortable with
	programming in C or C++.</li>

	<li>Provide low level bare metal access as required.</li>

	<li>Make D substantially easier to implement a compiler for than C++.</li>

	<li>Be compatible with the local C application binary interface.</li>

	<li>Have a context-free grammar.</li>

	<li>Easily support writing internationalized applications.</li>

	<li>Incorporate Contract Programming and unit testing methodology.</li>

	<li>Be able to build lightweight, standalone programs.</li>

	<li>Reduce the costs of creating documentation.</li>
    </ul>


<h3>Features To Keep From C/C++</h3>

	<p>The general look of D is like C and C++. This makes it easier to learn
	and port code to D. Transitioning from C/C++ to D should feel natural.
	The 
	programmer will not have to learn an entirely new way of doing things.
	</p>

	<p>Using D will not mean that the programmer will become restricted to a
	specialized runtime vm (virtual machine) like the Java vm or the
	Smalltalk vm.
	There is no D vm, it's a straightforward compiler that generates
	linkable object files.
	D connects to the operating system just like C does.
	The usual familiar tools like <b>make</b> will fit right in with
	D development.
	</p>

    <ul>	<li>The general <b>look and feel</b> of C/C++ is maintained.
	It uses the same algebraic syntax, most of the same expression
	and statement forms, and the general layout.
	</li>

	<li>D programs can be written either in
	C style <b>function-and-data</b>,
	C++ style <b>object-oriented</b>,
	C++ style <b>template metaprogramming</b>,
	or any mix of the three.
	</li>

	<li>The <b>compile/link/debug</b> development model is
	carried forward,
	although nothing precludes D from being compiled into bytecode
	and interpreted. 
	</li>

	<li><b>Exception handling</b>.
	More and more experience with exception handling shows it to be a 
	superior way to handle errors than the C traditional method of using
	error codes and errno globals.
	</li>

	<li><b>Runtime Type Identification</b>.
	This is partially implemented in C++;
	in D it is taken to its 
	next logical step. Fully supporting it enables better garbage
	collection, better debugger support, more automated persistence, etc.
	</li>

	<li>D maintains function link compatibility with the <b>C calling
	conventions</b>. This makes 
	it possible for D programs to access operating system API's directly.
	Programmers' knowledge and experience with existing programming API's
	and paradigms can be carried forward to D with minimal effort.
	</li>

	<li><b>Operator overloading</b>.
	D programs can overload operators enabling
	extension of the basic types with user defined types.
	</li>

	<li><b>Template Metaprogramming</b>.
	Templates are a way to implement generic programming.
	Other ways include using macros or having a variant data type.
	Using macros is out. Variants are straightforward, but 
	inefficient and lack type checking.
	The difficulties with C++ templates are their
	complexity, they don't fit well into the syntax of the language,
	all the various rules for conversions and overloading fitted on top of
	it, etc. D offers a much simpler way of doing templates.
	</li>

	<li><acronym title="Resource Acquisition Is Initialization"><b>RAII</b></acronym>
	(Resource Acquisition Is Initialization).
	RAII techniques are an essential component of writing reliable
	software.
	</li>

	<li><b>Down and dirty programming</b>. D retains the ability to
	do down-and-dirty programming without resorting to referring to
	external modules compiled in a different language. Sometimes,
	it's just necessary to coerce a pointer or dip into assembly
	when doing systems work. D's goal is not to <i>prevent</i> down
	and dirty programming, but to minimize the need for it in
	solving routine coding tasks.
	</li>
    </ul>


<h3>Features To Drop</h3>

<ul>	<li>C source code compatibility. Extensions to C that maintain
	source compatibility 
	have already been done (C++ and ObjectiveC). Further work in this
	area is hampered by so much legacy code it is unlikely that significant
	improvements can be made.
	</li>

	<li>Link compatibility with C++. The C++ runtime object model is just
	too complicated - properly supporting it would essentially imply
	making D a full C++ compiler too.
	</li>

	<li>The C preprocessor. Macro processing is an easy way to extend
	a language, adding in faux features that aren't really there (invisible
	to the symbolic debugger). Conditional compilation, layered with
	#include text, macros, token concatenation, etc., essentially forms
	not one language but two merged together with no obvious distinction
	between them. Even worse (or perhaps for the best) the C preprocessor
	is a very primitive macro language. It's time to step back, look at
	what the preprocessor is used for, and design support for those
	capabilities directly into the language.
	</li>

	<li>Multiple inheritance. It's a complex
	feature of debatable value. It's very difficult to implement in an
	efficient manner, and compilers are prone to many bugs in implementing
	it. Nearly all the value of
	<acronym title="multiple inheritance">MI</acronym> can be handled with
	single inheritance
	coupled with interfaces and aggregation. What's left does not
	justify the weight of MI implementation.
	</li>

	<li>Namespaces. An attempt to deal with the problems resulting from
	linking together independently developed pieces of code that
	have conflicting names. The idea of modules is simpler and works
	much better.
	</li>

	<li>Tag name space. This misfeature of C is where the tag names
	of structs are in a separate but parallel symbol table. C++
	attempted to merge the tag name space with the regular name space,
	while retaining backward compatibility with legacy C code. The
	result is needlessly confusing.
	</li>

	<li>Forward declarations. C compilers semantically only know
	about what has lexically preceded the current state. C++ extends this
	a little, in that class members can rely on forward referenced class
	members. D takes this to its logical conclusion, forward declarations
	are no longer necessary at the module level.
	Functions can be defined in a natural
	order rather than the typical inside-out order commonly used in C
	programs to avoid writing forward declarations.
	</li>

	<li>Include files. A major cause of slow compiles as each
	compilation unit
	must reparse enormous quantities of header files. Include files
	should be done as importing a symbol table.
	</li>

	<li>Trigraphs and digraphs. Unicode is the future.
	</li>

	<li>Non-virtual member functions. In C++, a class designer decides
	in advance if a function is to be virtual or not. Forgetting to retrofit
	the base class member function to be virtual when the function gets
	overridden is a common (and very hard to find) coding error.
	Making all member functions virtual, and letting the compiler decide
	if there are no overrides and hence can be converted to non-virtual,
	is much more reliable.
	</li>

	<li>Bit fields of arbitrary size.
	Bit fields are a complex, inefficient feature rarely used.
	</li>

	<li>Support for 16 bit computers.
	No consideration is given in D for mixed near/far pointers and all the
	machinations necessary to generate good 16 bit code. The D language
	design assumes at least a 32 bit flat memory space. D will fit smoothly
	into 64 bit architectures.
	</li>

	<li>Mutual dependence of compiler passes. In C++, successfully parsing
	the source text relies on having a symbol table, and on the various
	preprocessor commands. This makes it
	impossible to preparse C++ source, and makes writing code analyzers
	and syntax directed editors painfully difficult to do correctly.
	</li>

	<li>Compiler complexity. Reducing the complexity of an implementation
	makes it more likely that multiple, <i>correct</i> implementations
	are available.
	</li>

	<li>Distinction between . and -&gt;. This distinction
	is really not necessary. The . operator serves just as well for
	pointer dereferencing.
	</li>
</ul>


<h3>Who D is For</h3>

<ul>	<li>Programmers who routinely use lint or similar code analysis tools
	to eliminate bugs before the code is even compiled.
	</li>

	<li>People who compile with maximum warning levels turned on and who 
	instruct the compiler to treat warnings as errors.
	</li>

	<li>Programming managers who are forced to rely on programming style 
	guidelines to avoid common C bugs.
	</li>

	<li>Those who decide the promise of C++ object oriented
	programming is not fulfilled due to the complexity of it.
	</li>

	<li>Programmers who enjoy the expressive power of C++ but are
	frustrated by
	the need to expend much effort explicitly managing memory and finding
	pointer bugs.
	</li>

	<li>Projects that need built-in testing and verification.
	</li>

	<li>Teams who write apps with a million lines of code in it.
	</li>

	<li>Programmers who think the language should provide enough
	features to obviate 
	the continual necessity to manipulate pointers directly.
	</li>

	<li>Numerical programmers. D has many features to directly
	support features needed by numerics programmers, like direct support
	for the complex data type and
	defined behavior for
	<acronym title="Not A Number">NaN</acronym>'s and infinities.
	(These are added in the new
	C99 standard, but not in C++.)
	</li>

	<li>D's lexical analyzer and parser are totally independent of each other and of the 
	semantic analyzer. This means it is easy to write simple tools to manipulate D source 
	perfectly without having to build a full compiler. It also means that source code can be 
	transmitted in tokenized form for specialized applications.
	</li>
</ul>


<h3>Who D is Not For</h3>

    <ul>	<li>Realistically, nobody is going to convert million line C or C++
	programs into D, and since D does not compile unmodified C/C++
	source code, D is not for 
	legacy apps. (However, D supports legacy C API's very well.)
	</li>

	<li>Very small programs - a scripting or interpreted language like
	Python,
	<a href="http://www.digitalmars.com/dscript/index.html">DMDScript</a>,
	or Perl is likely more suitable.
	</li>

	<li>As a first programming language - Basic or Java is more suitable
	for beginners. D makes an excellent second language for intermediate
	to advanced programmers.
	</li>

	<li>Language purists. D is a practical language, and each feature
	of it is evaluated in that light, rather than by an ideal.
	For example, D has constructs and semantics that virtually eliminate
	the need for pointers for ordinary tasks. But pointers are still
	there, because sometimes the rules need to be broken.
	Similarly, casts are still there for those times when the typing
	system needs to be overridden.
	</li>
    </ul>






<h2>Major Features of D</h2>

	<p>This section lists some of the more interesting features of D
	in various categories.
	</p>

<h3>Object Oriented Programming</h3>

    <h4>Classes</h4>

	<p>D's object oriented nature comes from classes.
	The inheritance model is single inheritance enhanced
	with interfaces. The class Object sits at the root
	of the inheritance hierarchy, so all classes implement
	a common set of functionality.
	Classes are instantiated
	by reference, and so complex code to clean up after exceptions
	is not required.
	</p>
    


    <h4>Operator Overloading</h4>

	<p>Classes can be crafted that work with existing operators to extend
	the type system to support new types. An example would be creating
	a bignumber class and then overloading the +, -, * and / operators
	to enable using ordinary algebraic syntax with them.
	</p>
    



<h3>Productivity</h3>

    <h4>Modules</h4>

	<p>Source files have a one-to-one correspondence with modules.
	Instead of #include'ing the text of a file of declarations,
	just import the module. There is no need to worry about
	multiple imports of the same module, no need to wrapper header
	files with <tt>#ifndef/#endif</tt> or <tt>#pragma once</tt> kludges,
	etc.
	</p>
    


    <h4>Declaration vs Definition</h4>

	<p>C++ usually requires that functions and classes be declared twice - the declaration
	that goes in the .h header file, and the definition that goes in the .c source
	file. This is an error prone and tedious process. Obviously, the programmer 
	should only need to write it once, and the compiler should then extract the 
	declaration information and make it available for symbolic importing. This is 
	exactly how D works.
	</p>

	<p>Example:
	</p>

<pre class="d_code"><span class="d_keyword">class</span> ABC
{
    <span class="d_keyword">int</span> func() { <span class="d_keyword">return</span> 7; }
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> z = 7;
}
<span class="d_keyword">int</span> q;
</pre>

	<p>There is no longer a need for a separate definition of member functions, static
	members, externs, nor for clumsy syntaxes like:
	</p>

<pre class="ccode">int ABC::func() { return 7; }
int ABC::z = 7;
extern int q;
</pre>

	<p>Note: Of course, in C++, trivial functions like <tt>{ return 7; }</tt>
	are written inline too, but complex ones are not. In addition, if
	there are any forward references, the functions need to be prototyped.
	The following will not work in C++:
	</p>

<pre class="ccode">class Foo
{
    int foo(Bar *c) { return c-&gt;bar(); }
};

class Bar
{
  public:
    int bar() { return 3; }
};
</pre>

	<p>But the equivalent D code will work:
	</p>

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">int</span> foo(Bar c) { <span class="d_keyword">return</span> c.bar; }
}

<span class="d_keyword">class</span> Bar
{
    <span class="d_keyword">int</span> bar() { <span class="d_keyword">return</span> 3; }
}
</pre>

	<p>Whether a D function is inlined or not is determined by the
	optimizer settings.
	</p>
    


    <h4>Templates</h4>

	<p>D templates offer a clean way to support generic programming while
	offering the power of partial specialization.
	</p>
    


    <h4>Associative Arrays</h4>

	<p>Associative arrays are arrays with an arbitrary data type as
	the index rather than being limited to an integer index.
	In essence, associated arrays are hash tables. Associative
	arrays make it easy to build fast, efficient, bug-free symbol
	tables.
	</p>
    


    <h4>Real Typedefs</h4>

	<p>C and C++ typedefs are really type <i>aliases</i>, as no new
	type is really introduced. D implements real typedefs, where:
	</p>

<pre class="d_code"><span class="d_keyword">typedef</span> <span class="d_keyword">int</span> handle;
</pre>

	<p>really does create a new type <b>handle</b>. Type checking is
	enforced, and typedefs participate in function overloading.
	For example:
	</p>

<pre class="d_code"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> i);
<span class="d_keyword">int</span> foo(handle h);
</pre>
    


    <h4>Documentation</h4>

	<p>Documentation has traditionally been done twice - first there
	are comments documenting what a function does, and then this gets
	rewritten into a separate html or man page.
	And naturally, over time, they'll tend to diverge as the code
	gets updated and the separate documentation doesn't.
	Being able to generate the requisite polished documentation directly
	from the comments embedded in the source will not only cut the time
	in half needed to prepare documentation, it will make it much easier
	to keep the documentation in sync with the code.
	<a href="ddoc.html">Ddoc</a> is the specification for the D
	documentation generator. This page was generated by Ddoc, too.
	</p>

	<p>Although third party tools exist to do this for C++, they have some
	serious shortcomings:

	<ul>
	<li>It is spectacularly difficult to parse C++ 100% correctly. To
	do so really requires a full C++ compiler. Third party tools tend to
	parse only a subset of C++ correctly, so their use will constrain
	the source code to that subset.</li>

	<li>Different compilers support different versions of C++ and have
	different extensions to C++. Third party tools have a problem matching
	all these variations.</li>

	<li>Third party tools may not be available for all the desired
	platforms, and they're necessarily on a different upgrade cycle
	from the compilers.</li>

	<li>Having it builtin to the compiler means it is standardized across
	all D implementations. Having a default one ready to go at all times
	means it is far more likely to be used.</li>

	</ul>
	</p>
    



<h3>Functions</h3>

	<p>D has the expected support for ordinary functions including
	global functions, overloaded functions, inlining of functions,
	member functions, virtual functions, function pointers, etc.
	In addition:
	</p>

    <h4>Nested Functions</h4>

	<p>Functions can be nested within other functions.
	This is highly useful for code factoring, locality, and
	function closure techniques.
	</p>
    


    <h4>Function Literals</h4>

	<p>Anonymous functions can be embedded directly into an expression.
	</p>
    


    <h4>Dynamic Closures</h4>

	<p>Nested functions and class member functions can be referenced
	with closures (also called delegates), making generic programming
	much easier and type safe.
	</p>
    


    <h4>In Out and Inout Parameters</h4>

	<p>Not only does specifying this help make functions more
	self-documenting, it eliminates much of the necessity for pointers
	without sacrificing anything, and it opens up possibilities
	for more compiler help in finding coding problems.
	</p>

	<p>Such makes it possible for D to directly interface to a
	wider variety of foreign API's. There would be no need for
	workarounds like "Interface Definition Languages".
	</p>
    



<h3>Arrays</h3>

	<p>C arrays have several faults that can be corrected:
	</p>

	<ul>
	<li>Dimension information is not carried around with
	the array, and so has to be stored and passed separately.
	The classic example of this are the argc and argv
	parameters to <tt>main(int <span class="d_param">argc</span>
, char *<span class="d_param">argv</span>
[])</tt>.
	(In D, main is declared as <tt>main(char[][] <span class="d_param">args</span>
)</tt>.)
	</li>

	<li>Arrays are not first class objects. When an array	is passed to a function, it is
	converted to a pointer, even though the prototype confusingly says it's an 
	array. When this conversion happens, all array type information
	gets lost.
	</li>

	<li>C arrays cannot be resized. This means that even simple aggregates like a stack 
	need to be constructed as a complex class.</li>

	<li>C arrays cannot be bounds checked, because they don't know
	what the array bounds are.</li>

	<li>Arrays are declared with the [] after the identifier. This leads to
	very clumsy 
	syntax to declare things like a pointer to an array:

<pre class="ccode">int (*array)[3];
</pre>

	<p>In D, the [] for the array go on the left:
	</p>

<pre class="d_code"><span class="d_keyword">int</span>[3]* array;		<span class="d_comment">// declares a pointer to an array of 3 ints
</span><span class="d_keyword">long</span>[] func(<span class="d_keyword">int</span> x);	<span class="d_comment">// declares a function returning an array of longs
</span></pre>

	<p>which is much simpler to understand.
	</p>
	</li>
	</ul>

	<p>D arrays come in several varieties: pointers, static arrays, dynamic
	arrays, and associative arrays.
	</p>

	<p>See <a href="arrays.html">Arrays</a>.
	</p>

    <h4>Strings</h4>

	<p>String manipulation is so common, and so clumsy in C and C++, that
	it needs direct support in the language. Modern languages handle
	string concatenation, copying, etc., and so does D. Strings are
	a direct consequence of improved array handling.
	</p>
    



<h3>Resource Management</h3>

    <h4>Automatic Memory Management</h4>

	<p>D memory allocation is fully garbage collected. Empirical experience
	suggests that a lot of the complicated features of C++ are necessary
	in order to manage memory deallocation. With garbage collection, the
	language gets much simpler.
	</p>

	<p>There's a perception that garbage collection is for lazy, junior
	programmers. I remember when that was said about C++, after all,
	there's nothing in C++ that cannot be done in C, or in assembler
	for that matter.
	</p>

	<p>Garbage collection eliminates the tedious, error prone memory
	allocation
	tracking code necessary in C and C++. This not only means much
	faster development time and lower maintenance costs,
	but the resulting program frequently runs
	faster!
	</p>

	<p>Sure, garbage collectors can be used with C++, and I've used them
	in my own C++ projects. The language isn't friendly to collectors,
	however, impeding the effectiveness of it. Much of the runtime
	library code can't be used with
	collectors.
	</p>

	<p>For a fuller discussion of this, see
	<a href="garbage.html">garbage collection</a>.
	</p>
    


    <h4>Explicit Memory Management</h4>

	<p>Despite D being a garbage collected language, the new and delete
	operations can be overridden for particular classes so that
	a custom allocator can be used.
	</p>
    


    <h4>RAII</h4>

	<p>RAII is a modern software development technique to manage resource
	allocation and deallocation. D supports RAII in a controlled,
	predictable manner that is independent of the garbage collection
	cycle.
	</p>
    




<h3>Performance</h3>

    <h4>Lightweight Aggregates</h4>

	<p>D supports simple C style structs, both for compatibility with
	C data structures and because they're useful when the full power
	of classes is overkill.
	</p>
    


    <h4>Inline Assembler</h4>

	<p>Device drivers, high performance system applications, embedded systems,
	and specialized code sometimes need to dip into assembly language
	to get the job done. While D implementations are not required
	to implement the inline assembler, it is defined and part of the
	language. Most assembly code needs can be handled with it,
	obviating the need for separate assemblers or DLL's.
	</p>

	<p>Many D implementations will also support intrinsic functions
	analogously to C's support of intrinsics for I/O port manipulation,
	direct access to special floating point operations, etc.
	</p>
    




<h3>Reliability</h3>

	<p>A modern language should do all it can to help the programmer flush
	out bugs in the code. Help can come in many forms;
	from making it easy to use more robust techniques, 
	to compiler flagging of obviously incorrect code, to runtime checking.
	</p>

    <h4>Contracts</h4>

	<p>Contract Programming (invented by B. Meyer) is a revolutionary
	technique
	to aid in ensuring the correctness of programs. D's version of
	DBC includes function preconditions, function postconditions, class
	invariants, and assert contracts.
	See <a href="dbc.html">Contracts</a> for D's implementation.
	</p>
    


    <h4>Unit Tests</h4>

	<p>Unit tests can be added to a class, such that they are automatically
	run upon program startup. This aids in verifying, in every build,
	that class implementations weren't inadvertently broken. The unit
	tests form part of the source code for a class. Creating them
	becomes a natural part of the class development process, as opposed
	to throwing the finished code over the wall to the testing group.
	</p>

	<p>Unit tests can be done in other languages, but the result is kludgy
	and the languages just aren't accommodating of the concept.
	Unit testing is a main feature of D. For library functions it works
	out great, serving both to guarantee that the functions
	actually work and to illustrate how to use the functions.
	</p>

	<p>Consider the many C++ library and application code bases out there for
	download on the web. How much of it comes with *any* verification
	tests at all, let alone unit testing? Less than 1%? The usual practice
	is if it compiles, we assume it works. And we wonder if the warnings
	the compiler spits out in the process are real bugs or just nattering
	about nits.
	</p>

	<p>Along with Contract Programming, unit testing makes D far and away
	the best language for writing reliable, robust systems applications.
	Unit testing also gives us a quick-and-dirty estimate of the quality
	of some unknown piece of D code dropped in our laps - if it has no
	unit tests and no contracts, it's unacceptable.
	</p>
    



    <h4>Debug Attributes and Statements</h4>

	<p>Now debug is part of the syntax of the language.
	The code can be enabled or disabled at compile time, without the
	use of macros or preprocessing commands. The debug syntax enables
	a consistent, portable, and understandable recognition that real
	source code needs to be able to generate both debug compilations and
	release compilations.
	</p>
    


    <h4>Exception Handling</h4>

	<p>The superior <i>try-catch-finally</i> model is used rather than just
	try-catch. There's no need to create dummy objects just to have
	the destructor implement the <i>finally</i> semantics.
	</p>
    


    <h4>Synchronization</h4>

	<p>Multithreaded programming is becoming more and more mainstream,
	and D provides primitives to build multithreaded programs with.
	Synchronization can be done at either the method or the object level.
	</p>

<pre class="d_code"><span class="d_keyword">synchronized</span> <span class="d_keyword">int</span> func() { ... }
</pre>

	<p>Synchronized functions allow only one thread at a time to be
	executing that function.
	</p>

	<p>The synchronize statement puts a mutex around a block of statements,
	controlling access either by object or globally.
	</p>
    


    <h4>Support for Robust Techniques</h4>

	<ul>	<li>Dynamic arrays instead of pointers</li>

	<li>Reference variables instead of pointers</li>

	<li>Reference objects instead of pointers</li>

	<li>Garbage collection instead of explicit memory management</li>

	<li>Built-in primitives for thread synchronization</li>

	<li>No macros to inadvertently slam code</li>

	<li>Inline functions instead of macros</li>

	<li>Vastly reduced need for pointers</li>

	<li>Integral type sizes are explicit</li>

	<li>No more uncertainty about the signed-ness of chars</li>

	<li>No need to duplicate declarations in source and header files.</li>

	<li>Explicit parsing support for adding in debug code.</li>
	</ul>
    


    <h4>Compile Time Checks</h4>

	<ul>	<li>Stronger type checking</li>

	<li>No empty ; for loop bodies</li>

	<li>Assignments do not yield boolean results</li>

	<li>Deprecating of obsolete API's</li>
	</ul>
    


    <h4>Runtime Checking</h4>

	<ul>	<li>assert() expressions</li>

	<li>array bounds checking</li>

	<li>undefined case in switch exception</li>

	<li>out of memory exception</li>

	<li>In, out, and class invariant Contract Programming support</li>
	</ul>
    



<h3>Compatibility</h3>

    <h4>Operator precedence and evaluation rules</h4>

	<p>D retains C operators and their precedence rules, order of
	evaluation rules, and promotion rules. This avoids subtle
	bugs that might arise from being so used to the way C
	does things that one has a great deal of trouble finding
	bugs due to different semantics.
	</p>
    


    <h4>Direct Access to C API's</h4>

	<p>Not only does D have data types that correspond to C types,
	it provides direct access to C functions. There is no need
	to write wrapper functions, parameter swizzlers, nor code to copy
	aggregate members one by one.
	</p>
    


    <h4>Support for all C data types</h4>

	<p>Making it possible to interface to any C API or existing C
	library code. This support includes structs, unions, enums,
	pointers, and all C99 types.
	D includes the capability to
	set the alignment of struct members to ensure compatibility with
	externally imposed data formats.
	</p>
    


    <h4>OS Exception Handling</h4>

	<p>D's exception handling mechanism will connect to the way
	the underlying operating system handles exceptions in
	an application.
	</p>
    


    <h4>Uses Existing Tools</h4>

	<p>D produces code in standard object file format, enabling the use
	of standard assemblers, linkers, debuggers, profilers, exe compressors,
	and other analyzers, as well as linking to code written in other
	languages.
	</p>
    



<h3>Project Management</h3>

    <h4>Versioning</h4>

	<p>D provides built-in support for generation of multiple versions
	of a program from the same text. It replaces the C preprocessor
	#if/#endif technique.
	</p>
    


    <h4>Deprecation</h4>

	<p>As code evolves over time, some old library code gets replaced
	with newer, better versions. The old versions must be available
	to support legacy code, but they can be marked as <i>deprecated</i>.
	Code that uses deprecated versions will be normally flagged
	as illegal, but would be allowed by a compiler switch.
	This will making it easy for maintenance
	programmers to identify any dependence on deprecated features.
	</p>
    





<h2>Sample D Program (sieve.d)</h2>

<pre class="d_code"><span class="d_comment">/* Sieve of Eratosthenes prime numbers */</span>
 
<span class="d_keyword">bool</span>[8191] flags;
 
<span class="d_keyword">int</span> main()
{   <span class="d_keyword">int</span> i, count, prime, k, iter;

    printf(<span class="d_string">"10 iterations\n"</span>);
    <span class="d_keyword">for</span> (iter = 1; iter &lt;= 10; iter++)
    {	count = 0;
	flags[] = 1;
	<span class="d_keyword">for</span> (i = 0; i &lt; flags.length; i++)
	{   <span class="d_keyword">if</span> (flags[i])
	    {	prime = i + i + 3;
		k = i + prime;
		<span class="d_keyword">while</span> (k &lt; flags.length)
		{
		    flags[k] = 0;
		    k += prime;
		}
		count += 1;
	    }
	}
    }
    printf (<span class="d_string">"\n%d primes"</span>, count);
    <span class="d_keyword">return</span> 0;
}
</pre>



  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Overview" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/overview.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>


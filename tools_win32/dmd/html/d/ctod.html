
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/ctod.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:32:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Digital Mars - Programming in D for C Programmers</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/ctod" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Fri Jun 16 00:33:14 2006
</div>
</div>

<!-- Generated by Ddoc from ctod.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="comparison.html">D vs C/C++/C#/Java</a></li>

	<li><a href="builtin.html">   Rationale for Builtins</a></li>

	<li><a href="ctod.html">      Converting C to D</a></li>

	<li><a href="cpptod.html">    Converting C++ to D</a></li>

	<li><a href="pretod.html">The C Preprocessor vs D</a></li>

	<li><a href="cppstrings.html">D strings vs C++ std::string</a></li>

	<li><a href="cppcomplex.html">D complex vs C++ std::complex</a></li>

	<li><a href="cppdbc.html">    D Contract Programming vs C++</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>Programming in D for C Programmers</h1>
  
<blockquote><p>
Et tu, D? Then fall, C! -- William Nerdspeare
</p></blockquote>


<img src="c1.html" border=0 align=right alt="ouch!">

Every experienced C programmer accumulates a series of idioms and techniques
which become second nature. Sometimes, when learning a new language, those
idioms can be so comfortable it's hard to see how to do the equivalent in the
new language. So here's a collection of common C techniques, and how to do the
corresponding task in D.
<p>

Since C does not have object-oriented features, there's a separate section
for object-oriented issues
<a href="cpptod.html">Programming in D for C++ Programmers</a>.
<p>

The C preprocessor is covered in
<a href="pretod.html">The C Preprocessor vs D</a>.

<ul>
	<li><a href="#sizeof">Getting the Size of a Type</a>
	<li><a href="#maxmin">Get the max and min values of a type</a>
	<li><a href="#types">Primitive Types</a>
	<li><a href="#floating">Special Floating Point Values</a>
	<li><a href="#modulus">Remainder after division of floating point numbers</a>
	<li><a href="#nans">Dealing with NAN's in floating point compares</a>
	<li><a href="#assert">Asserts</a>
	<li><a href="#arrayinit">Initializing all elements of an array</a>
	<li><a href="#arrayloop">Looping through an array</a>
	<li><a href="#arraycreate">Creating an array of variable size</a>
	<li><a href="#strcat">String Concatenation</a>
	<li><a href="#printf">Formatted printing</a>
	<li><a href="#forwardfunc">Forward referencing functions</a>
	<li><a href="#funcvoid">Functions that have no arguments</a>
	<li><a href="#labelledbreak">Labelled break's and continue's</a>
	<li><a href="#goto">Goto Statements</a>
	<li><a href="#tagspace">Struct tag name space</a>
	<li><a href="#stringlookup">Looking up strings</a>
	<li><a href="#align">Setting struct member alignment</a>
	<li><a href="#anonymous">Anonymous Structs and Unions</a>
	<li><a href="#declaring">Declaring struct types and variables</a>
	<li><a href="#fieldoffset">Getting the offset of a struct member</a>
	<li><a href="#unioninit">Union initializations</a>
	<li><a href="#structinit">Struct initializations</a>
	<li><a href="#arrayinit2">Array initializations</a>
	<li><a href="#stringlit">Escaped String Literals</a>
	<li><a href="#ascii">Ascii vs Wide Characters</a>
	<li><a href="#arrayenum">Arrays that parallel an enum</a>
	<li><a href="#typedefs">Creating a new typedef'd type</a>
	<li><a href="#structcmp">Comparing structs</a>
	<li><a href="#stringcmp">Comparing strings</a>
	<li><a href="#sort">Sorting arrays</a>
	<li><a href="#volatile">Volatile memory access</a>
	<li><a href="#strings">String literals</a>
	<li><a href="#traversal">Data Structure Traversal</a>
	<li><a href="#ushr">Unsigned Right Shift</a>
	<li><a href="#closures">Dynamic Closures</a>
	<li><a href="#variadic">Variadic Function Parameters</a>

<!--
	<li><a href="#"></a>
  -->
</ul>

<hr><!-- -------------------------------------------- -->
<h3><a name="sizeof">Getting the Size of a Type</a></h3>

<h4>The C Way</h4>

<pre class="ccode">sizeof(int)
sizeof(char *)
sizeof(double)
sizeof(struct Foo)
</pre>

<h4>The D Way</h4>

<P>Use the size property:</P>

<pre class="d_code"><span class="d_keyword">int</span>.sizeof
(<span class="d_keyword">char</span> *).sizeof
<span class="d_keyword">double</span>.sizeof
Foo.sizeof
</pre>

<hr><!-- ============================================ -->
<a name="maxmin"></a>
<h3>Get the max and min values of a type</h3>

<h4>The C Way</h4>

<pre class="ccode">#include &lt;limits.h&gt;
#include &lt;math.h&gt;

CHAR_MAX
CHAR_MIN
ULONG_MAX
DBL_MIN
</pre>

<h4>The D Way</h4>

<pre class="d_code"><span class="d_keyword">char</span>.max
<span class="d_keyword">char</span>.min
<span class="d_keyword">ulong</span>.max
<span class="d_keyword">double</span>.min
</pre>

<hr><!-- ============================================ -->
<a name="types"></a>
<h3>Primitive Types</h3>

<h4>C to D types</h4>

<pre class="ccode">bool               =&gt;        bit 
char               =&gt;        char 
signed char        =&gt;        byte 
unsigned char      =&gt;        ubyte 
short              =&gt;        short 
unsigned short     =&gt;        ushort 
wchar_t            =&gt;        wchar 
int                =&gt;        int 
unsigned           =&gt;        uint 
long               =&gt;        int 
unsigned long      =&gt;        uint 
long long          =&gt;        long 
unsigned long long =&gt;        ulong 
float              =&gt;        float 
double             =&gt;        double 
long double        =&gt;        real 
_Imaginary long double =&gt;    imaginary
_Complex long double   =&gt;    complex
</pre>
<p>
       Although char is an unsigned 8 bit type, and 
       wchar is an unsigned 16 bit type, they have their own separate types 
       in order to aid overloading and type safety. 
<p>
       Ints and unsigneds in C are of varying size; not so in D. 

<hr><!-- ============================================ -->
<a name="floating"></a>
<h3>Special Floating Point Values</h3>

<h4>The C Way</h4>

<pre class="ccode">#include &lt;fp.h&gt; 

NAN 
INFINITY 

#include &lt;float.h&gt; 

DBL_DIG 
DBL_EPSILON 
DBL_MANT_DIG 
DBL_MAX_10_EXP 
DBL_MAX_EXP 
DBL_MIN_10_EXP 
DBL_MIN_EXP 
</pre>

<h4>The D Way</h4>

<pre class="d_code"><span class="d_keyword">double</span>.nan 
<span class="d_keyword">double</span>.infinity 
<span class="d_keyword">double</span>.dig 
<span class="d_keyword">double</span>.epsilon 
<span class="d_keyword">double</span>.mant_dig 
<span class="d_keyword">double</span>.max_10_exp 
<span class="d_keyword">double</span>.max_exp 
<span class="d_keyword">double</span>.min_10_exp 
<span class="d_keyword">double</span>.min_exp 
</pre>

<hr><!-- ============================================ -->
<h3><a name="modulus">Remainder after division of floating point numbers</a></h3>

<h4>The C Way</h4>

<pre class="ccode">#include &lt;math.h&gt; 

float f = fmodf(x,y); 
double d = fmod(x,y); 
long double r = fmodl(x,y); 
</pre>

<h4>The D Way</h4>

D supports the remainder ('%') operator on floating point operands: 

<pre class="d_code"><span class="d_keyword">float</span> f = x % y; 
<span class="d_keyword">double</span> d = x % y; 
<span class="d_keyword">real</span> r = x % y; 
</pre>

<hr><!-- ============================================ -->
<a name="nans"></a>
<h3>Dealing with NAN's in floating point compares</h3>

<h4>The C Way</h4>

       C doesn't define what happens if an operand to a compare 
       is NAN, and few C compilers check for it (the Digital Mars 
       C compiler is an exception, DM's compilers do check for NAN operands). 

<pre class="ccode">#include &lt;math.h&gt; 

if (isnan(x) || isnan(y)) 
   result = FALSE; 
else 
   result = (x &lt; y); 
</pre>

<h4>The D Way</h4>

       D offers a full complement of comparisons and operators 
       that work with NAN arguments. 

<pre class="d_code">result = (x &lt; y);        <span class="d_comment">// false if x or y is nan 
</span></pre>

<hr><!-- ============================================ -->
<a name="assert"></a>
<h3>Assert's are a necessary part of any good defensive coding strategy.</h3>

<h4>The C Way</h4>
<p>
C doesn't directly support assert, but does support __FILE__ 
and __LINE__ from which an assert macro can be built. In fact, 
there appears to be practically no other use for __FILE__ and __LINE__. 

<pre class="ccode">#include &lt;assert.h&gt; 

assert(e == 0); 
</pre>

<h4>The D Way</h4>

D simply builds assert into the language: 

<pre class="d_code"><span class="d_keyword">assert</span>(e == 0); 
</pre>

<hr><!-- ============================================ -->
<a name="arrayinit"></a>
<h3>Initializing all elements of an array</h3>

<h4>The C Way</h4>

<pre class="ccode">#define ARRAY_LENGTH        17 
int array[ARRAY_LENGTH]; 
for (i = 0; i &lt; ARRAY_LENGTH; i++) 
   array[i] = value; 
</pre>

<h4>The D Way</h4>

<pre class="d_code"><span class="d_keyword">int</span> array[17]; 
array[] = value; 
</pre>

<hr><!-- ============================================ -->
<a name="arrayloop"></a>
<h3>Looping through an array</h3>

<h4>The C Way</h4>
<p>
       The array length is defined separately, or a clumsy 
       sizeof() expression is used to get the length. 

<pre class="ccode">#define ARRAY_LENGTH        17 
int array[ARRAY_LENGTH]; 
for (i = 0; i &lt; ARRAY_LENGTH; i++) 
   func(array[i]); 
</pre>

or: 

<pre class="ccode">int array[17]; 
for (i = 0; i &lt; sizeof(array) / sizeof(array[0]); i++) 
   func(array[i]); 
</pre>

<h4>The D Way</h4>

The length of an array is accessible the property "length". 

<pre class="d_code"><span class="d_keyword">int</span> array[17]; 
<span class="d_keyword">for</span> (i = 0; i &lt; array.length; i++) 
   func(array[i]); 
</pre>

or even better:

<pre class="d_code"><span class="d_keyword">int</span> array[17]; 
<span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> value; array)
   func(value); 
</pre>


<hr><!-- ============================================ -->
<a name="arraycreate"></a>
<h3>Creating an array of variable size</h3>

<h4>The C Way</h4>

       C cannot do this with arrays. It is necessary to create a separate 
       variable for the length, and then explicitly manage the size of 
       the array: 

<pre class="ccode">#include &lt;stdlib.h&gt; 

int array_length; 
int *array; 
int *newarray; 

newarray = (int *)
   realloc(array, (array_length + 1) * sizeof(int)); 
if (!newarray) 
   error("out of memory"); 
array = newarray; 
array[array_length++] = x; 
</pre>

<h4>The D Way</h4>

       D supports dynamic arrays, which can be easily resized. D supports 
       all the requisite memory management. 

<pre class="d_code"><span class="d_keyword">int</span>[] array; 

array.length = array.length + 1;
array[array.length - 1] = x; 
</pre>

<hr><!-- ============================================ -->
<a name="strcat"></a>
<h3>String Concatenation</h3>

<h4>The C Way</h4>

       There are several difficulties to be resolved, like 
       when can storage be free'd, dealing with null pointers, 
       finding the length of the strings, and memory allocation: 

<pre class="ccode">#include &lt;string.h&gt; 

char *s1; 
char *s2; 
char *s; 

// Concatenate s1 and s2, and put result in s 
free(s); 
s = (char *)malloc((s1 ? strlen(s1) : 0) + 
		  (s2 ? strlen(s2) : 0) + 1); 
if (!s) 
   error("out of memory"); 
if (s1) 
   strcpy(s, s1); 
else 
   *s = 0; 
if (s2) 
   strcpy(s + strlen(s), s2); 

// Append "hello" to s 
char hello[] = "hello"; 
char *news; 
size_t lens = s ? strlen(s) : 0; 
news = (char *)
   realloc(s, (lens + sizeof(hello) + 1) * sizeof(char)); 
if (!news) 
   error("out of memory"); 
s = news; 
memcpy(s + lens, hello, sizeof(hello)); 
</pre>

<h4>The D Way</h4>

       D overloads the operators ~ and ~= for char and wchar arrays to mean 
       concatenate and append, respectively: 

<pre class="d_code"><span class="d_keyword">char</span>[] s1; 
<span class="d_keyword">char</span>[] s2; 
<span class="d_keyword">char</span>[] s; 

s = s1 ~ s2; 
s ~= <span class="d_string">"hello"</span>; 
</pre>

<hr><!-- ============================================ -->
<a name="printf"></a>
<h3>Formatted printing</h3>

<h4>The C Way</h4>

       printf() is the general purpose formatted print routine: 

<pre class="ccode">#include &lt;stdio.h&gt; 

printf("Calling all cars %d times!\n", ntimes); 
</pre>

<h4>The D Way</h4>

       What can we say? printf() rules: 

<pre class="d_code"><span class="d_keyword">import</span> stdio; 

printf(<span class="d_string">"Calling all cars %d times!\n"</span>, ntimes); 
</pre>

<hr><!-- ============================================ -->
<a name="forwardfunc"></a>
<h3>Forward referencing functions</h3>

<h4>The C Way</h4>

       Functions cannot be forward referenced. Hence, to call a function 
       not yet encountered in the source file, it is necessary to insert 
       a function declaration lexically preceding the call. 

<pre class="ccode">void forwardfunc(); 

void myfunc() 
{   
   forwardfunc(); 
} 

void forwardfunc() 
{   
   ... 
} 
</pre>

<h4>The D Way</h4>

	The program is looked at as a whole, and so not only is it not 
	necessary to code forward declarations, it is not even allowed! 
	D avoids the tedium and errors associated with writing forward 
	referenced function declarations twice. 
	Functions can be defined in any order.

<pre class="d_code"><span class="d_keyword">void</span> myfunc() 
{   
   forwardfunc(); 
} 

<span class="d_keyword">void</span> forwardfunc() 
{   
   ... 
} 
</pre>

<hr><!-- ============================================ -->
<a name="funcvoid"></a>
<h3>Functions that have no arguments</h3>

<h4>The C Way</h4>

<pre class="ccode">void function(void); 
</pre>

<h4>The D Way</h4>

       D is a strongly typed language, so there is no need to explicitly 
       say a function takes no arguments, just don't declare it has having 
       arguments. 

<pre class="d_code"><span class="d_keyword">void</span> <span class="d_keyword">function</span>()
{
   ...
}
</pre>

<hr><!-- ============================================ -->
<a name="labelledbreak"></a>
<h3>Labelled break's and continue's.</h3>

<h4>The C Way</h4>

       Break's and continue's only apply to the innermost nested loop or 
       switch, so a multilevel break must use a goto: 

<pre class="ccode">    for (i = 0; i &lt; 10; i++) 
    {   
       for (j = 0; j &lt; 10; j++) 
       {   
	   if (j == 3) 
	       goto Louter; 
	   if (j == 4) 
	       goto L2; 
       } 
     L2: 
       ; 
    } 
Louter: 
    ; 
</pre>

<h4>The D Way</h4>

       Break and continue statements can be followed by a label. The label 
       is the label for an enclosing loop or switch, and the break applies 
       to that loop. 

<pre class="d_code">Louter: 
   <span class="d_keyword">for</span> (i = 0; i &lt; 10; i++) 
   {   
       <span class="d_keyword">for</span> (j = 0; j &lt; 10; j++) 
       {   
	   <span class="d_keyword">if</span> (j == 3) 
	       <span class="d_keyword">break</span> Louter; 
	   <span class="d_keyword">if</span> (j == 4) 
	       <span class="d_keyword">continue</span> Louter; 
       } 
   } 
   <span class="d_comment">// break Louter goes here 
</span></pre>

<hr><!-- ============================================ -->
<a name="goto"></a>
<h3>Goto Statements</h3>

<h4>The C Way</h4>

       The much maligned goto statement is a staple for professional C coders. It's 
       necessary to make up for sometimes inadequate control flow statements. 

<h4>The D Way</h4>

       Many C-way goto statements can be eliminated with the D feature of labelled 
       break and continue statements. But D is a practical language for practical 
       programmers who know when the rules need to be broken. So of course D supports 
       the goto! 

<hr><!-- ============================================ -->
<h3><a name="tagspace">Struct tag name space</a></h3>

<h4>The C Way</h4>

       It's annoying to have to put the struct keyword every time a type is specified, 
       so a common idiom is to use: 

<pre class="ccode">typedef struct ABC { ... } ABC; 
</pre>

<h4>The D Way</h4>

       Struct tag names are not in a separate name space, they are in the same name 
       space as ordinary names. Hence: 

<pre class="d_code"><span class="d_keyword">struct</span> ABC { ... }; 
</pre>

<hr><!-- ============================================ -->
<a name="stringlookup"></a>
<h3>Looking up strings</h3>

<h4>The C Way</h4>

       Given a string, compare the string against a list of possible 
       values and take action based on which one it is. A typical use 
       for this might be command line argument processing. 

<pre class="ccode">#include &lt;string.h&gt; 
void dostring(char *s) 
{   
   enum Strings { Hello, Goodbye, Maybe, Max }; 
   static char *table[] = { "hello", "goodbye", "maybe" }; 
   int i; 

   for (i = 0; i &lt; Max; i++) 
   {   
       if (strcmp(s, table[i]) == 0) 
	   break; 
   } 
   switch (i) 
   {   
       case Hello:   ... 
       case Goodbye: ... 
       case Maybe:   ... 
       default:      ... 
   } 
} 
</pre>

       The problem with this is trying to maintain 3 parallel data 
       structures, the enum, the table, and the switch cases. If there 
       are a lot of values, the connection between the 3 may not be so 
       obvious when doing maintenance, and so the situation is ripe for 
       bugs. 

       Additionally, if the number of values becomes large, a binary or 
       hash lookup will yield a considerable performance increase over 
       a simple linear search. But coding these can be time consuming, 
       and they need to be debugged. It's typical that such just never 
       gets done. 

<h4>The D Way</h4>

       D extends the concept of switch statements to be able to handle 
       strings as well as numbers. Then, the way to code the string 
       lookup becomes straightforward: 

<pre class="d_code"><span class="d_keyword">void</span> dostring(<span class="d_keyword">char</span>[] s) 
{   
   <span class="d_keyword">switch</span> (s) 
   {   
       <span class="d_keyword">case</span> <span class="d_string">"hello"</span>:   ... 
       <span class="d_keyword">case</span> <span class="d_string">"goodbye"</span>: ... 
       <span class="d_keyword">case</span> <span class="d_string">"maybe"</span>:   ... 
       <span class="d_keyword">default</span>:        ... 
   } 
} 
</pre>

       Adding new cases becomes easy. The compiler can be relied on 
       to generate a fast lookup scheme for it, eliminating the bugs 
       and time required in hand-coding one. 

<hr><!-- ============================================ -->
<a name="align"></a>
<h3>Setting struct member alignment</h3>

<h4>The C Way</h4>

       It's done through a command line switch which affects the entire 
       program, and woe results if any modules or libraries didn't get 
       recompiled. To address this, #pragma's are used: 

<pre class="ccode">#pragma pack(1) 
struct ABC 
{   
   ... 
}; 
#pragma pack() 
</pre>

       But #pragmas are nonportable both in theory and in practice from 
       compiler to compiler. 

<h4>The D Way</h4>

       Clearly, since much of the point to setting alignment is for 
       portability of data, a portable means of expressing it is necessary. 

<pre class="d_code"><span class="d_keyword">struct</span> ABC 
{   
   <span class="d_keyword">int</span> z;               <span class="d_comment">// z is aligned to the default 
</span>
 <span class="d_keyword">align</span> (1) <span class="d_keyword">int</span> x;       <span class="d_comment">// x is byte aligned 
</span> <span class="d_keyword">align</span> (4) 
 {   
   ...                  <span class="d_comment">// declarations in {} are dword aligned 
</span> } 
 <span class="d_keyword">align</span> (2):             <span class="d_comment">// switch to word alignment from here on 
</span>
   <span class="d_keyword">int</span> y;               <span class="d_comment">// y is word aligned 
</span>} 
</pre>

<hr><!-- ============================================ -->
<a name="anonymous"></a>
<h3>Anonymous Structs and Unions</h3>

Sometimes, it's nice to control the layout of a struct with nested structs and unions. 

<h4>The C Way</h4>

       C doesn't allow anonymous structs or unions, which means that dummy tag names 
       and dummy members are necessary: 

<pre class="ccode">struct Foo 
{
   int i; 
   union Bar 
   {
      struct Abc { int x; long y; } _abc; 
      char *p; 
   } _bar; 
}; 

#define x _bar._abc.x 
#define y _bar._abc.y 
#define p _bar.p 

struct Foo f; 

f.i; 
f.x; 
f.y; 
f.p; 
</pre>

       Not only is it clumsy, but using macros means a symbolic debugger won't understand 
       what is being done, and the macros have global scope instead of struct scope. 

<h4>The D Way</h4>

       Anonymous structs and unions are used to control the layout in a 
       more natural manner: 

<pre class="d_code"><span class="d_keyword">struct</span> Foo 
{
   <span class="d_keyword">int</span> i; 
   <span class="d_keyword">union</span> 
   {
      <span class="d_keyword">struct</span> { <span class="d_keyword">int</span> x; <span class="d_keyword">long</span> y; } 
      <span class="d_keyword">char</span>* p; 
   } 
} 

Foo f; 

f.i; 
f.x; 
f.y; 
f.p; 
</pre>

<hr><!-- ============================================ -->
<a name="declaring"></a>
<h3>Declaring struct types and variables.</h3>

<h4>The C Way</h4>

       Is to do it in one statement ending with a semicolon: 

<pre class="ccode">struct Foo { int x; int y; } foo; 
</pre>

       Or to separate the two: 

<pre class="ccode">struct Foo { int x; int y; };   // note terminating ; 
struct Foo foo; 
</pre>

<h4>The D Way</h4>

       Struct definitions and declarations can't be done in the same statement: 

<pre class="d_code"><span class="d_keyword">struct</span> Foo { <span class="d_keyword">int</span> x; <span class="d_keyword">int</span> y; }    <span class="d_comment">// note there is no terminating ; 
</span>Foo foo; 
</pre>

       which means that the terminating ; can be dispensed with, eliminating the 
       confusing difference between struct {} and function &amp; block {} in how semicolons 
       are used. 

<hr><!-- ============================================ -->
<a name="fieldoffset"></a>
<h3>Getting the offset of a struct member.</h3>

<h4>The C Way</h4>

       Naturally, another macro is used: 

<pre class="ccode">#include &lt;stddef&gt; 
struct Foo { int x; int y; }; 

off = offsetof(Foo, y); 
</pre>

<h4>The D Way</h4>

       An offset is just another property: 

<pre class="d_code"><span class="d_keyword">struct</span> Foo { <span class="d_keyword">int</span> x; <span class="d_keyword">int</span> y; } 

off = Foo.y.offset; 
</pre>

<hr><!-- ============================================ -->
<a name="unioninit"></a>
<h3>Union initializations.</h3>

<h4>The C Way</h4>

       Unions are initialized using the "first member" rule: 

<pre class="ccode">union U { int a; long b; }; 
union U x = { 5 };                // initialize member 'a' to 5 
</pre>

       Adding union members or rearranging them can have disastrous consequences 
       for any initializers. 

<h4>The D Way</h4>

       In D, which member is being initialized is mentioned explicitly: 

<pre class="d_code"><span class="d_keyword">union</span> U { <span class="d_keyword">int</span> a; <span class="d_keyword">long</span> b; } 
U x = { a:5 } 
</pre>

       avoiding the confusion and maintenance problems. 

<hr><!-- ============================================ -->
<a name="structinit"></a>
<h3>Struct initializations.</h3>

<h4>The C Way</h4>

       Members are initialized by their position within the {}'s: 

<pre class="ccode">struct S { int a; int b; }; 
struct S x = { 5, 3 }; 
</pre>

       This isn't much of a problem with small structs, but when there 
       are numerous members, it becomes tedious to get the initializers 
       carefully lined up with the field declarations. Then, if members are 
       added or rearranged, all the initializations have to be found and 
       modified appropriately. This is a minefield for bugs. 

<h4>The D Way</h4>

       Member initialization can be done explicitly: 

<pre class="d_code"><span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> a; <span class="d_keyword">int</span> b; } 
S x = { b:3, a:5 } 
</pre>

       The meaning is clear, and there no longer is a positional dependence. 

<hr><!-- ============================================ -->
<a name="arrayinit2"></a>
<h3>Array initializations.</h3>

<h4>The C Way</h4>

       C initializes array by positional dependence: 
<pre class="ccode">int a[3] = { 3,2,2 }; 
</pre>
       Nested arrays may or may not have the { }: 
<pre class="ccode">int b[3][2] = { 2,3, {6,5}, 3,4 }; 
</pre>

<h4>The D Way</h4>

       D does it by positional dependence too, but an index can be used as well: 
       The following all produce the same result: 

<pre class="d_code"><span class="d_keyword">int</span>[3] a = [ 3, 2, 0 ]; 
<span class="d_keyword">int</span>[3] a = [ 3, 2 ];            <span class="d_comment">// unsupplied initializers are 0, just like in C 
</span><span class="d_keyword">int</span>[3] a = [ 2:0, 0:3, 1:2 ]; 
<span class="d_keyword">int</span>[3] a = [ 2:0, 0:3, 2 ];     <span class="d_comment">// if not supplied, the index is the
</span>				<span class="d_comment">// previous one plus one. 
</span></pre>
       This can be handy if the array will be indexed by an enum, and the order of 
       enums may be changed or added to: 

<pre class="d_code"><span class="d_keyword">enum</span> color { black, red, green }
<span class="d_keyword">int</span>[3] c = [ black:3, green:2, red:5 ]; 
</pre>
       Nested array initializations must be explicit: 
<pre class="d_code"><span class="d_keyword">int</span>[2][3] b = [ [2,3], [6,5], [3,4] ]; 

<span class="d_keyword">int</span>[2][3] b = [[2,6,3],[3,5,4]];            <span class="d_comment">// error 
</span></pre>

<hr><!-- ============================================ -->
<a name="stringlit"></a>
<h3>Escaped String Literals</h3>

<h4>The C Way</h4>

       C has problems with the DOS file system because a \ is an escape in a string. To specifiy file c:\root\file.c: 
<pre class="ccode">char file[] = "c:\\root\\file.c"; 
</pre>
This gets even more unpleasant with regular expressions.
Consider the escape sequence to match a quoted string: 
<pre class="ccode">/"[^\\]*(\\.[^\\]*)*"/
</pre>
<P>In C, this horror is expressed as: 
<pre class="ccode">char quoteString[] = "\"[^\\\\]*(\\\\.[^\\\\]*)*\"";
</pre>
<h4>The D Way</h4>

	Within strings, it is WYSIWYG (what you see is what you get).
	Escapes are in separate strings. So: 

<pre class="d_code"><span class="d_keyword">char</span>[] file = <span class="d_string">`c:\root\file.c`</span>; 
<span class="d_keyword">char</span>[] quoteString = <span class="d_string">\"</span>  <span class="d_string">r"[^\\]*(\\.[^\\]*)*"</span>  <span class="d_string">\"</span>;
</pre>

       The famous hello world string becomes: 
<pre class="d_code"><span class="d_keyword">char</span>[] hello = <span class="d_string">"hello world"</span> <span class="d_string">\n</span>; 
</pre>

<hr><!-- ============================================ -->
<a name="ascii"></a>
<h3>Ascii vs Wide Characters</h3>

<P>Modern programming requires that wchar strings be supported in an easy way, for internationalization of the programs. 

<h4>The C Way</h4>

       C uses the wchar_t and the L prefix on strings: 
<pre class="ccode">#include &lt;wchar.h&gt; 
char foo_ascii[] = "hello"; 
wchar_t foo_wchar[] = L"hello"; 
</pre>
Things get worse if code is written to be both ascii and wchar compatible.
A macro is used to switch strings from ascii to wchar: 
<pre class="ccode">#include &lt;tchar.h&gt; 
tchar string[] = TEXT("hello"); 
</pre>
<h4>The D Way</h4>

The type of a string is determined by semantic analysis, so there is no need to wrap strings in a macro call: 
<pre class="d_code"><span class="d_keyword">char</span>[] foo_ascii = <span class="d_string">"hello"</span>;        <span class="d_comment">// string is taken to be ascii 
</span><span class="d_keyword">wchar</span>[] foo_wchar = <span class="d_string">"hello"</span>;       <span class="d_comment">// string is taken to be wchar 
</span></pre>

<hr><!-- ============================================ -->
<a name="arrayenum"></a>
<h3>Arrays that parallel an enum</h3>

<h4>The C Way</h4>

       Consider: 
<pre class="ccode">enum COLORS { red, blue, green, max }; 
char *cstring[max] = {"red", "blue", "green" }; 
</pre>
       This is fairly easy to get right because the number of entries is small. But suppose it gets to be fairly large. Then it can get difficult to maintain correctly when new entries are added. 

<h4>The D Way</h4>
<pre class="d_code"><span class="d_keyword">enum</span> COLORS { red, blue, green }

<span class="d_keyword">char</span>[][COLORS.max + 1] cstring = 
[
    COLORS.red   : <span class="d_string">"red"</span>,
    COLORS.blue  : <span class="d_string">"blue"</span>, 
    COLORS.green : <span class="d_string">"green"</span>,
]; 
</pre>

Not perfect, but better. 

<hr><!-- ============================================ -->
<a name="typedefs"></a>
<h3>Creating a new typedef'd type</h3>

<h4>The C Way</h4>

	Typedef's in C are weak, that is, they really do not introduce
	a new type. The compiler doesn't distinguish between a typedef
	and its underlying type.

<pre class="ccode">typedef void *Handle;
void foo(void *);
void bar(Handle);

Handle h;
foo(h);			// coding bug not caught
bar(h);			// ok
</pre>

	The C solution is to create a dummy struct whose sole
	purpose is to get type checking and overloading on the new type.

<pre class="ccode">struct Handle__ { void *value; }
typedef struct Handle__ *Handle;
void foo(void *);
void bar(Handle);

Handle h;
foo(h);			// syntax error
bar(h);			// ok
</pre>

	Having a default value for the type involves defining a macro,
	a naming convention, and then pedantically following that convention:

<pre class="ccode">#define HANDLE_INIT ((Handle)-1)

Handle h = HANDLE_INIT;
h = func();
if (h != HANDLE_INIT)
    ...
</pre>

	For the struct solution, things get even more complex:

<pre class="ccode">struct Handle__ HANDLE_INIT;

void init_handle()	// call this function upon startup
{
    HANDLE_INIT.value = (void *)-1;
}

Handle h = HANDLE_INIT;
h = func();
if (memcmp(&h,&HANDLE_INIT,sizeof(Handle)) != 0)
    ...
</pre>

	There are 4 names to remember: <tt>Handle, HANDLE_INIT,
	struct Handle__, value</tt>.

<h4>The D Way</h4>

	No need for idiomatic constructions like the above. Just write:

<pre class="d_code"><span class="d_keyword">typedef</span> <span class="d_keyword">void</span>* Handle;
<span class="d_keyword">void</span> foo(<span class="d_keyword">void</span>*);
<span class="d_keyword">void</span> bar(Handle);

Handle h;
foo(h);
bar(h);
</pre>

	To handle a default value, add an initializer to the typedef,
	and refer to it with the <tt>.init</tt> property:

<pre class="d_code"><span class="d_keyword">typedef</span> <span class="d_keyword">void</span>* Handle = <span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)(-1);
Handle h;
h = func();
<span class="d_keyword">if</span> (h != Handle.init)
    ...
</pre>

	There's only one name to remember: <tt>Handle</tt>.

<hr><!-- ============================================ -->
<a name="structcmp"></a>
<h3>Comparing structs</h3>

<h4>The C Way</h4>

	While C defines struct assignment in a simple, convenient manner:

<pre class="ccode">struct A x, y;
...
x = y;
</pre>

	it does not for struct comparisons. Hence, to compare two struct
	instances for equality:

<pre class="ccode">#include &lt;string.h&gt;

struct A x, y;
...
if (memcmp(&x, &y, sizeof(struct A)) == 0)
    ...
</pre>

	Note the obtuseness of this, coupled with the lack of any kind
	of help from the language with type checking.
	<p>

	There's a nasty bug lurking in the memcmp().
	The layout of a struct, due to alignment, can have 'holes' in it.
	C does not guarantee those holes are assigned any values, and so
	two different struct instances can have the same value for each member,
	but compare different because the holes contain different garbage.

<h4>The D Way</h4>

	D does it the obvious, straightforward way:

<pre class="d_code">A x, y;
...
<span class="d_keyword">if</span> (x == y)
    ...
</pre>


<hr><!-- ============================================ -->
<h3><a name="stringcmp">Comparing strings</a></h3>

<h4>The C Way</h4>

	The library function strcmp() is used:
<pre class="ccode">char string[] = "hello";

if (strcmp(string, "betty") == 0)	// do strings match?
    ...
</pre>

	C uses 0 terminated strings, so the C way has an inherent
	inefficiency in constantly scanning for the terminating 0.

<h4>The D Way</h4>

	Why not use the == operator?

<pre class="d_code"><span class="d_keyword">char</span>[] string = <span class="d_string">"hello"</span>;

<span class="d_keyword">if</span> (string == <span class="d_string">"betty"</span>)
    ...
</pre>

	D strings have the length stored separately from the string.
	Thus, the implementation of string compares can be much faster
	than in C (the difference being equivalent to the difference
	in speed between the C memcmp() and strcmp()).
	<p>

	D supports comparison operators on strings, too:

<pre class="d_code"><span class="d_keyword">char</span>[] string = <span class="d_string">"hello"</span>;

<span class="d_keyword">if</span> (string &lt; <span class="d_string">"betty"</span>)
    ...
</pre>

	which is useful for sorting/searching.

<hr><!-- ============================================ -->
<h3><a name="sort">Sorting arrays</a></h3>

<h4>The C Way</h4>

	Although many C programmers tend to reimplmement bubble sorts
	over and over, the right way to sort in C is to use qsort():

<pre class="ccode">int compare(const void *p1, const void *p2)
{
    type *t1 = (type *)p1;
    type *t1 = (type *)p2;

    return *t1 - *t2;
}

type array[10];
...
qsort(array, sizeof(array)/sizeof(array[0]),
	sizeof(array[0]), compare);
</pre>

	A compare() must be written for each type, and much careful
	typo-prone code needs to be written to make it work.


<h4>The D Way</h4>

	Sorting couldn't be easier:

<pre class="d_code">type[] array;
...
array.sort;      <span class="d_comment">// sort array in-place
</span></pre>

<hr><!-- ============================================ -->
<h3><a name="volatile">Volatile memory access</a></h3>

<h4>The C Way</h4>

	To access volatile memory, such as shared memory
	or memory mapped I/O, a pointer to volatile is created:
<pre class="ccode">volatile int *p = address;

i = *p;
</pre>

<h4>The D Way</h4>

	D has volatile as a statement type, not as a type modifier:

<pre class="d_code"><span class="d_keyword">int</span>* p = address;

<span class="d_keyword">volatile</span> { i = *p; }
</pre>

<hr><!-- ============================================ -->
<h3><a name="strings">String literals</a></h3>

<h4>The C Way</h4>

	String literals in C cannot span multiple lines, so to have
	a block of text it is necessary to use \ line splicing:

<pre class="ccode">"This text spans\n\
multiple\n\
lines\n"
</pre>

	If there is a lot of text, this can wind up being tedious.

<h4>The D Way</h4>

	String literals can span multiple lines, as in:

<pre class="d_code"><span class="d_string">"This text spans
multiple
lines
"</span>
</pre>

	So blocks of text can just be cut and pasted into the D
	source.

<hr><!-- ============================================ -->
<h3><a name="traversal">Data Structure Traversal</a></h3>

<h4>The C Way</h4>

    Consider a function to traverse a recursive data structure.
    In this example, there's a simple symbol table of strings.
    The data structure is an array of binary trees.
    The code needs to do an exhaustive search of it to find
    a particular string in it, and determine if it is a unique
    instance.
    <p>

    To make this work, a helper function <tt>membersearchx</tt>
    is needed to recursively
    walk the trees. The helper function needs to read and write
    some context outside of the trees, so a custom <tt>struct Paramblock</tt>
    is created and a pointer to it is used to maximize efficiency.

<pre class="ccode">struct Symbol
{
   char *id;
   struct Symbol *left;
   struct Symbol *right;
};

struct Paramblock
{
   char *id;
   struct Symbol *sm;
};

static void membersearchx(struct Paramblock *p, struct Symbol *s)
{
   while (s)
   {
      if (strcmp(p-&gt;id,s-&gt;id) == 0)
      {
         if (p-&gt;sm)
            error("ambiguous member %s\n",p-&gt;id);
         p-&gt;sm = s;
      }

      if (s-&gt;left)
         membersearchx(p,s-&gt;left);
      s = s-&gt;right;
   }
}

struct Symbol *symbol_membersearch(Symbol *table[], int tablemax, char *id)
{
   struct Paramblock pb;
   int i;

   pb.id = id;
   pb.sm = NULL;
   for (i = 0; i &lt; tablemax; i++)
   {
      membersearchx(pb, table[i]);
   }
   return pb.sm;
}
</pre>

<h4>The D Way</h4>

    This is the same algorithm in D, and it shrinks dramatically.
    Since nested functions have access to the lexically enclosing
    function's variables, there's no need for a Paramblock or
    to deal with its bookkeeping details. The nested helper function
    is contained wholly within the function that needs it,
    improving locality and maintainability.
    <p>

    The performance of the two versions is indistinguishable.

<pre class="d_code"><span class="d_keyword">class</span> Symbol
{   <span class="d_keyword">char</span>[] id;
    Symbol left;
    Symbol right;
}

Symbol symbol_membersearch(Symbol[] table, <span class="d_keyword">char</span>[] id)
{   Symbol sm;

    <span class="d_keyword">void</span> membersearchx(Symbol s)
    {
	<span class="d_keyword">while</span> (s)
	{
	    <span class="d_keyword">if</span> (id == s.id)
	    {
		<span class="d_keyword">if</span> (sm)
		    error(<span class="d_string">"ambiguous member %s\n"</span>, id);
		sm = s;
	    }

	    <span class="d_keyword">if</span> (s.left)
		membersearchx(s.left);
	    s = s.right;
	}
    }

    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; table.length; i++)
    {
	membersearchx(table[i]);
    }
    <span class="d_keyword">return</span> sm;
}
</pre>

<hr><!-- ============================================ -->
<h3><a name="ushr">Unsigned Right Shift</a></h3>

<h4>The C Way</h4>

	The right shift operators &gt;&gt; and &gt;&gt;= are signed
	shifts if the left operand is a signed integral type, and
	are unsigned right shifts if the left operand is an unsigned
	integral type. To produce an unsigned right shift on an int,
	a cast is necessary:

<pre class="ccode">int i, j;
...
j = (unsigned)i &gt;&gt; 3;
</pre>

	If <tt>i</tt> is an <tt>int</tt>, this works fine. But if <tt>i</tt> is
	of a typedef'd type,

<pre class="ccode">myint i, j;
...
j = (unsigned)i &gt;&gt; 3;
</pre>

	and <tt>myint</tt> happens to be a <tt>long int</tt>, then the cast to
	unsigned
	will silently throw away the most significant bits, corrupting
	the answer.

<h4>The D Way</h4>

	D has the right shift operators &gt;&gt; and &gt;&gt;= which
	behave as they do in C. But D also has explicitly unsigned
	right shift operators &gt;&gt;&gt; and &gt;&gt;&gt;= which will
	do an unsigned right shift regardless of the sign of the left
	operand. Hence,

<pre class="d_code">myint i, j;
...
j = i &gt;&gt;&gt; 3;
</pre>

	avoids the unsafe cast and will work as expected with any integral
	type.

<hr><!-- ============================================ -->
<h3><a name="closures">Dynamic Closures</a></h3>

<h4>The C Way</h4>

	Consider a reusable container type. In order to be reusable,
	it must support a way to apply arbitrary code to each element
	of the container. This is done by creating an <i>apply</i> function
	that accepts a function pointer to which is passed each
	element of the container contents.
	<p>

	A generic context pointer is also needed, represented here by
	<tt>void *p</tt>. The example here is of a trivial container
	class that holds an array of int's, and a user of that container
	that computes the maximum of those int's.

<pre class="ccode">struct Collection
{
    int array[10];

    void apply(void *p, void (*fp)(void *, int))
    {
	for (int i = 0; i &lt; sizeof(array)/sizeof(array[0]); i++)
	    fp(p, array[i]);
    }
};

void comp_max(void *p, int i)
{
    int *pmax = (int *)p;

    if (i &gt; *pmax)
	*pmax = i;
}

void func(Collection *c)
{
    int max = INT_MIN;

    c-&gt;apply(&amp;max, comp_max);
}
</pre>

	The C way makes heavy use of pointers and casting.
	The casting is tedious, error prone, and loses all type safety.

<h4>The D Way</h4>

	The D version makes use of <i>delegates</i> to transmit
	context information for the <i>apply</i> function,
	and <i>nested functions</i> both to capture context
	information and to improve locality.

<pre class="d_code"><span class="d_keyword">class</span> Collection
{
    <span class="d_keyword">int</span>[10] array;

    <span class="d_keyword">void</span> apply(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">int</span>) fp)
    {
	<span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; array.length; i++)
	    fp(array[i]);
    }
}

<span class="d_keyword">void</span> func(Collection c)
{
    <span class="d_keyword">int</span> max = <span class="d_keyword">int</span>.min;

    <span class="d_keyword">void</span> comp_max(<span class="d_keyword">int</span> i)
    {
	<span class="d_keyword">if</span> (i &gt; max)
	    max = i;
    }

    c.apply(comp_max);
}
</pre>

	Pointers are eliminated, as well as casting and generic
	pointers. The D version is fully type safe.
	An alternate method in D makes use of <i>function literals</i>:

<pre class="d_code"><span class="d_keyword">void</span> func(Collection c)
{
    <span class="d_keyword">int</span> max = <span class="d_keyword">int</span>.min;

    c.apply(<span class="d_keyword">delegate</span>(<span class="d_keyword">int</span> i) { <span class="d_keyword">if</span> (i &gt; max) max = i; } );
}
</pre>

	eliminating the need to create irrelevant function names.

<hr><!-- ============================================ -->
<h3><a name="variadic">Variadic Function Parameters</a></h3>

	The task is to write a function that takes a varying
	number of arguments, such as a function that sums
	its arguments.

<h4>The C Way</h4>

<pre class="ccode">#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

int <b>sum</b>(int dim, ...)
{   int i;
    int s = 0;
    va_list ap;

    va_start(ap, dim);
    for (i = 0; i &lt; dim; i++)
	s += va_arg(ap, int);
    va_end(ap);
    return s;
}

int main()
{
    int i;

    i = <b>sum</b>(3, 8,7,6);
    printf("sum = %d\n", i);

    return 0;
} 
</pre>

	There are two problems with this. The first is that the
	<tt>sum</tt> function needs to know how many arguments were
	supplied. It has to be explicitly written, and it can get
	out of sync with respect to the actual number of arguments
	written.
	The second is that there's no way to check that the
	types of the arguments provided really were ints, and not
	doubles, strings, structs, etc.

<h4>The D Way</h4>

	The ... following an array parameter declaration means that
	the trailing arguments are collected together to form
	an array. The arguments are type checked against the array
	type, and the number of arguments becomes a property
	of the array:

<pre class="d_code"><span class="d_keyword">int</span> <b>sum</b>(<span class="d_keyword">int</span>[] values ...)
{
    <span class="d_keyword">int</span> s = 0;

    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; values)
	s += x;
    <span class="d_keyword">return</span> s;
}

<span class="d_keyword">int</span> main()
{
    <span class="d_keyword">int</span> i;

    i = <b>sum</b>(8,7,6);
    printf(<span class="d_string">"sum = %d\n"</span>, i);

    <span class="d_keyword">return</span> 0;
}
</pre>

  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/ctod" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/ctod.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:32:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>


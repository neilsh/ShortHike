
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/garbage.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - Garbage Collection</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Garbage" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Tue Jun  6 16:38:20 2006
</div>
</div>

<!-- Generated by Ddoc from garbage.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>

	<li><a href="module.html">Modules</a></li>

	<li><a href="declaration.html">Declarations</a></li>

	<li><a href="type.html">Types</a></li>

	<li><a href="property.html">Properties</a></li>

	<li><a href="attribute.html">Attributes</a></li>

	<li><a href="pragma.html">Pragmas</a></li>

	<li><a href="expression.html">Expressions</a></li>

	<li><a href="statement.html">Statements</a></li>

	<li><a href="arrays.html">Arrays</a></li>

	<li><a href="struct.html">Structs &amp; Unions</a></li>

	<li><a href="class.html">Classes</a></li>

	<li><a href="interface.html">Interfaces</a></li>

	<li><a href="enum.html">Enums</a></li>

	<li><a href="function.html">Functions</a></li>

	<li><a href="operatoroverloading.html">Operator Overloading</a></li>

	<li><a href="template.html">Templates</a></li>

	<li><a href="mixin.html">Mixins</a></li>

	<li><a href="dbc.html">Contracts</a></li>

	<li><a href="version.html">Conditional Compilation</a></li>

	<li><a href="errors.html">Handling errors</a></li>

	<li><a href="garbage.html">Garbage Collection</a></li>

	<li><a href="float.html">Floating Point</a></li>

	<li><a href="iasm.html">Inline Assembler</a></li>

	<li><a href="ddoc.html">Documentation Comments</a></li>

	<li><a href="interfaceToC.html">Interfacing To C</a></li>

	<li><a href="portability.html">Portability Guide</a></li>

	<li><a href="html.html">Embedding D in HTML</a></li>

	<li><a href="entity.html">Named Character Entities</a></li>

	<li><a href="abi.html">Application Binary Interface</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>     Garbage Collection</h1>
  
	D is a fully garbage collected language. That means that it is never necessary
	to free memory. Just allocate as needed, and the garbage collector will
	periodically return all unused memory to the pool of available memory.
	<p>

	C and C++ programmers accustomed to explicitly managing memory
	allocation and
	deallocation will likely be skeptical of the benefits and efficacy of
	garbage collection. Experience both with new projects written with
	garbage collection in mind, and converting existing projects to garbage
	collection shows that:

	<ul>

	<li> Garbage collected programs are faster. This is counterintuitive,
	but the reasons are:

	<ul>
	    <li> Reference counting is a common solution to solve explicit
	    memory allocation problems. The code to implement the increment and
	    decrement operations whenever assignments are made is one source
	    of slowdown. Hiding it behind smart pointer classes doesn't help
	    the speed. (Reference counting methods are not a general solution
	    anyway, as circular references never get deleted.)

	    <li> Destructors are used to deallocate resources acquired by an object.
	    For most classes, this resource is allocated memory.
	    With garbage collection, most destructors then become empty and
	    can be discarded entirely.

	    <li> All those destructors freeing memory can become significant when
	    objects are allocated on the stack. For each one, some mechanism must
	    be established so that if an exception happens, the destructors all
	    get called in each frame to release any memory they hold. If the
	    destructors become irrelevant, then there's no need to set up special
	    stack frames to handle exceptions, and the code runs faster.

	    <li> All the code necessary to manage memory can add up to quite a
	    bit. The larger a program is, the less in the cache it is,
	    the more paging it does, and the slower
	    it runs.

	    <li> Garbage collection kicks in only when memory gets tight. When
	    memory is not tight, the program runs at full speed and does not
	    spend any time freeing memory.

	    <li> Modern garbage collectors are far more advanced now than the
	    older, slower ones. Generational, copying collectors eliminate much
	    of the inefficiency of early mark and sweep algorithms.

	    <li> Modern garbage collectors do heap compaction. Heap compaction
	    tends to reduce the number of pages actively referenced by a program,
	    which means that memory accesses are more likely to be cache hits
	    and less swapping.

	    <li> Garbage collected programs do not suffer from gradual deterioration
	    due to an accumulation of memory leaks.
	</ul>


	<li> Garbage collectors reclaim unused memory, therefore they do not suffer
	from "memory leaks" which can cause long running applications to gradually
	consume more and more memory until they bring down the system. GC'd programs
	have longer term stability.

	<li> Garbage collected programs have fewer hard-to-find pointer bugs. This
	is because there are no dangling references to free'd memory. There is no
	code to explicitly manage memory, hence no bugs in such code.

	<li> Garbage collected programs are faster to develop and debug, because
	there's no need for developing, debugging, testing, or maintaining the
	explicit deallocation code.

	<li> Garbage collected programs can be significantly smaller, because
	there is no code to manage deallocation, and there is no need for exception
	handlers to deallocate memory.

	</ul>

	Garbage collection is not a panacea. There are some downsides:

	<ul>

	<li> It is not predictable when a collection gets run, so the program
	can arbitrarily pause.

	<li> The time it takes for a collection to run is not bounded. While in
	practice it is very quick, this cannot be guaranteed.

	<li> All threads other than the collector thread must be halted while
	the collection is in progress.

	<li> Garbage collectors can keep around some memory that an explicit deallocator
	would not. In practice, this is not much of an issue since explicit
	deallocators usually have memory leaks causing them to eventually use
	far more memory, and because explicit deallocators do not normally
	return deallocated memory to the operating system anyway, instead just
	returning it to its own internal pool.

	<li> Garbage collection should be implemented as a basic operating system
	kernel service. But since they are not, garbage collecting programs must
	carry around with them the garbage collection implementation. While this
	can be a shared DLL, it is still there.

	</ul>

	These constraints are addressed by techniques outlined
	in <a href="memory.html">Memory Management</a>.

<h2>How Garbage Collection Works</h2>

	To be written...

<h2>Interfacing Garbage Collected Objects With Foreign Code</h2>

	The garbage collector looks for roots in its static data segment, and the
	stacks and register contents of each thread. If the only root of an object
	is held outside of this, then the collecter will miss it and free the
	memory.
	<p>

	To avoid this from happening,

	<ul>
	<li> Maintain a root to the object in an area the collector does scan
	for roots.

	<li> Reallocate the object using the foreign code's storage allocator
	or using the C runtime library's malloc/free.
	</ul>

<h2>Pointers and the Garbage Collector</h2>

	Pointers in D can be broadly divided into two categories: those that
	point to garbage collected memory, and those that do not. Examples
	of the latter are pointers created by calls to C's malloc(), pointers
	received from C library routines, pointers to static data,
	pointers to objects on the stack, etc. For those pointers, anything
	that is legal in C can be done with them.
	<p>

	For garbage collected pointers and references, however, there are some
	restrictions. These restrictions are minor, but they are intended
	to enable the maximum flexibility in garbage collector design.
	<p>

	Undefined behavior:
	<ul>

	<li> Do not xor pointers with other values, like the
	xor'd pointer linked list trick used in C.
	<p>

	<li> Do not use the xor trick to swap two pointer values.
	<p>

	<li> Do not store pointers into non-pointer variables using casts and
	other tricks.

<pre class="d_code"><span class="d_keyword">void</span>* p;
...
<span class="d_keyword">int</span> x = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>)p;   <span class="d_comment">// error: undefined behavior
</span></pre>

	The garbage collector does not scan non-pointer types for roots.
	<p>

	<li> Do not take advantage of alignment of pointers to store bit flags
	in the low order bits:

<pre class="d_code">p = <span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)(<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>)p | 1);  <span class="d_comment">// error: undefined behavior
</span></pre>

	<li> Do not store into pointers values that may point into the
	garbage collected heap:

<pre class="d_code">p = <span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)12345678;   <span class="d_comment">// error: undefined behavior
</span></pre>

	A compacting garbage collector may change this value.
	<p>

	<li> Do not store magic values into pointers, other than <tt>null</tt>.
	<p>

	<li> Do not write pointer values out to disk and read them back in
	again.
	<p>

	<li> Do not use pointer values to compute a hash function. A copying
	garbage collector can arbitrarily move objects around in memory,
	thus invalidating
	the computed hash value.
	<p>

	<li> Do not depend on the ordering of pointers:

<pre class="d_code"><span class="d_keyword">if</span> (p1 &lt; p2)		<span class="d_comment">// error: undefined behavior
</span>    ...
</pre>
	since, again, the garbage collector can move objects around in
	memory.
	<p>

	<li> Do not add or subtract an offset to a pointer such that the result
	points outside of the bounds of the garbage collected object originally
	allocated.

<pre class="d_code"><span class="d_keyword">char</span>* p = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[10];
<span class="d_keyword">char</span>* q = p + 6;	<span class="d_comment">// ok
</span>q = p + 11;		<span class="d_comment">// error: undefined behavior
</span>q = p - 1;		<span class="d_comment">// error: undefined behavior
</span></pre>

	<li> Do not misaligned pointers if those pointers may
	point into the gc heap, such as:

<pre class="d_code"><span class="d_keyword">align</span> (1) <span class="d_keyword">struct</span> Foo
{   <span class="d_keyword">byte</span> b;
    <span class="d_keyword">char</span>* p;	<span class="d_comment">// misaligned pointer
</span>}
</pre>

	Misaligned pointers may be used if the underlying hardware
	supports them <b>and</b> the pointer is never used to point
	into the gc heap.
	<p>

	<li> Do not use byte-by-byte memory copies to copy pointer values.
	This may result in intermediate conditions where there is
	not a valid pointer, and if the gc pauses the thread in such a
	condition, it can corrupt memory.
	Most implementations of <tt>memcpy()</tt> will work since the
	internal implementation of it does the copy in aligned chunks
	greater than or equal to a pointer size, but since this kind of
	implementation is not guaranteed by the C standard, use
	<tt>memcpy()</tt> only with extreme caution.

	</ul>

	Things that are reliable and can be done:

	<ul>

	<li> Use a union to share storage with a pointer:

<pre class="d_code"><span class="d_keyword">union</span> U { <span class="d_keyword">void</span>* ptr; <span class="d_keyword">int</span> value }
</pre>

	Using such a union, however, as a substitute for a cast(int) will
	result in undefined behavior.
	<p>

	<li> A pointer to the start of a garbage collected object need not
	be maintained if a pointer to the interior of the object exists.

<pre class="d_code"><span class="d_keyword">char</span>[] p = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[10];
<span class="d_keyword">char</span>[] q = p[3..6];
<span class="d_comment">// q is enough to hold on to the object, don't need to keep
</span><span class="d_comment">// p as well.
</span></pre>

	</ul>

	One can avoid using pointers anyway for most tasks. D provides features
	rendering most explicit pointer uses obsolete, such as reference
	objects,
	dynamic arrays, and garbage collection. Pointers
	are provided in order to interface successfully with C API's and for
	some low level work.

<h2>Working with the Garbage Collector</h2>

	Garbage collection doesn't solve every memory deallocation problem. For
	example, if a root to a large data structure is kept, the garbage
	collector cannot reclaim it, even if it is never referred to again. To
	eliminate this problem, it is good practice to set a reference or
	pointer to an object to null when no longer needed.
	<p>

	This advice applies only to static references or references embedded
	inside other objects. There is not much point for such stored on the
	stack to be nulled, since the collector doesn't scan for roots past the
	top of the stack, and because new stack frames are initialized anyway.

<h2>References</h2>

	<ul>
	<li> <a href="http://www.iecc.com/gclist/GC-faq.html">GC FAQ</a>
	<li> <a href="../../../../../../../../ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps">Uniprocessor Garbage Collector Techniques</a>
	<li> <a href="http://www.amazon.com/exec/obidos/ASIN/0471941484/classicempire">
	Garbage Collection : Algorithms for Automatic Dynamic Memory Management</a>
	</ul>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Garbage" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/garbage.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>


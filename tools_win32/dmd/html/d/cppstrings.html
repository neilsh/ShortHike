
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/cppstrings.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:32:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - D Strings vs C++ Strings</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/CPPstrings" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Tue Jun 13 16:10:04 2006
</div>
</div>

<!-- Generated by Ddoc from cppstrings.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="comparison.html">D vs C/C++/C#/Java</a></li>

	<li><a href="builtin.html">   Rationale for Builtins</a></li>

	<li><a href="ctod.html">      Converting C to D</a></li>

	<li><a href="cpptod.html">    Converting C++ to D</a></li>

	<li><a href="pretod.html">The C Preprocessor vs D</a></li>

	<li><a href="cppstrings.html">D strings vs C++ std::string</a></li>

	<li><a href="cppcomplex.html">D complex vs C++ std::complex</a></li>

	<li><a href="cppdbc.html">    D Contract Programming vs C++</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>D Strings vs C++ Strings</h1>
  

Why have strings built-in to the core language of D rather than entirely in
a library as in C++ Strings? What's the point? Where's the improvement?

<h4>Concatenation Operator</h4>

<p>C++ Strings are stuck with overloading existing operators. The
	obvious choice for concatenation is += and +.
	But someone just looking at the code will see + and think "addition".
	He'll have to look up the types (and types are frequently buried
	behind multiple typedef's) to see that it's a string type, and
	it's not adding strings but concatenating them.
</p>
<p>Additionally, if one has an array of floats, is '+' overloaded to
	be the same as a vector addition, or an array concatenation?
</p>
<p>In D, these problems are avoided by introducing a new binary
	operator ~ as the concatenation operator. It works with
	arrays (of which strings are a subset). ~= is the corresponding
	append operator. ~ on arrays of floats would concatenate them,
	+ would imply a vector add. Adding a new operator makes it possible
	for orthogonality and consistency in the treatment of arrays.
	(In D, strings are simply arrays of characters, not a special
	type.)
</p>

<h4>Interoperability With C String Syntax</h4>

<p>Overloading of operators only really works if one of the operands
	is overloadable. So the C++ string class cannot consistently
	handle arbitrary expressions containing strings. Consider:
</p>

<pre class="ccode">const char abc[5] = "world";
string str = "hello" + abc;
</pre>

<p>That isn't going to work. But it does work when the core language
	knows about strings:
</p>

<pre class="ccode">const char[5] abc = "world";
char[] str = "hello" ~ abc;
</pre>

<h4>Consistency With C String Syntax</h4>

<p>	There are three ways to find the length of a string in C++:
</p>

<pre class="ccode">const char abc[] = "world";	:	sizeof(abc)/sizeof(abc[0])-1
				:	strlen(abc)
string str			:	str.length()
</pre>

<p>	That kind of inconsistency makes it hard to write generic templates.
	Consider D:
</p>

<pre class="d_code"><span class="d_keyword">char</span>[5] abc = <span class="d_string">"world"</span>;	:	abc.length
<span class="d_keyword">char</span>[] str		:	str.length
</pre>

<h4>Checking For Empty Strings</h4>

<p>	C++ strings use a function to determine if a string is empty:
</p>

<pre class="ccode">string str;
if (str.empty())
	// string is empty
</pre>

<p>	In D, an empty string has zero length:
</p>

<pre class="d_code"><span class="d_keyword">char</span>[] str;
<span class="d_keyword">if</span> (!str.length)
	<span class="d_comment">// string is empty
</span></pre>


<h4>Resizing Existing String</h4>

<p>	C++ handles this with the resize() member function:
</p>

<pre class="ccode">string str;
str.resize(newsize);
</pre>

<p>	D takes advantage of knowing that str is a string, and
	so resizing it is just changing the length property:
</p>

<pre class="d_code"><span class="d_keyword">char</span>[] str;
str.length = newsize;
</pre>

<h4>Slicing a String</h4>

<p>	C++ slices an existing string using a special constructor:
</p>

<pre class="ccode">string s1 = "hello world";
string s2(s1, 6, 5);		// s2 is "world"
</pre>

<p>	D has the array slice syntax, not possible with C++:
</p>

<pre class="d_code"><span class="d_keyword">char</span>[] s1 = <span class="d_string">"hello world"</span>;
<span class="d_keyword">char</span>[] s2 = s1[6 .. 11];	<span class="d_comment">// s2 is "world"
</span></pre>

<p>	Slicing, of course, works with any array in D, not just strings.
</p>

<h4>Copying a String</h4>

<p>	C++ copies strings with the replace function:
</p>

<pre class="ccode">string s1 = "hello world";
string s2 = "goodbye      ";
s2.replace(8, 5, s1, 6, 5);	// s2 is "goodbye world"
</pre>

<p>	D uses the slice syntax as an lvalue:
</p>

<pre class="d_code"><span class="d_keyword">char</span>[] s1 = <span class="d_string">"hello world"</span>;
<span class="d_keyword">char</span>[] s2 = <span class="d_string">"goodbye      "</span>;
s2[8..13] = s1[6..11];		<span class="d_comment">// s2 is "goodbye world"
</span></pre>

<h4>Conversions to C Strings</h4>

<p>	This is needed for compatibility with C API's. In C++, this
	uses the c_str() member function:
</p>

<pre class="ccode">void foo(const char *);
string s1;
foo(s1.c_str());
</pre>

<p>	In D, strings can be implicitly converted to char*:
</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">char</span>*);
<span class="d_keyword">char</span>[] s1;
foo(s1);
</pre>
	<p>although for this to work where <tt>foo</tt> expects a 0 terminated
	string, <tt>s1</tt> must have a terminating 0. Alternatively, the
	function <tt>std.string.toStringz</tt> will ensure it:</p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">char</span>*);
<span class="d_keyword">char</span>[] s1;
foo(std.string.<b>toStringz</b>(s1));
</pre>


<h4>Array Bounds Checking</h4>

<p>	In C++, string array bounds checking for [] is not done.
	In D, array bounds checking is on by default and it can be turned off
	with a compiler switch after the program is debugged.
</p>

<h4>String Switch Statements</h4>

<p>	Are not possible in C++, nor is there any way to add them
	by adding more to the library. In D, they take the obvious
	syntactical forms:
</p>

<pre class="d_code"><span class="d_keyword">switch</span> (str)
{
    <span class="d_keyword">case</span> <span class="d_string">"hello"</span>:
    <span class="d_keyword">case</span> <span class="d_string">"world"</span>:
	...
}
</pre>

<p>	where str can be any of literal "string"s, fixed string arrays
	like char[10], or dynamic strings like char[]. A quality implementation
	can, of course, explore many strategies of efficiently implementing
	this based on the contents of the case strings.
</p>

<h4>Filling a String</h4>

<p>	In C++, this is done with the replace() member function:
</p>

<pre class="ccode">string str = "hello";
str.replace(1,2,2,'?');		// str is "h??lo"
</pre>

<p>	In D, use the array slicing syntax in the natural manner:
</p>

<pre class="d_code"><span class="d_keyword">char</span>[] str = <span class="d_string">"hello"</span>;
str[1..3] = '?';		<span class="d_comment">// str is "h??lo"
</span></pre>

<h4>Value vs Reference</h4>

<p>	C++ strings, as implemented by STLport, are by value and are
	0-terminated. [The latter is an implementation choice, but
	STLport seems to be the most popular implementation.]
	This, coupled with no garbage collection, has
	some consequences. First of all, any string created must make
	its own copy of the string data. The 'owner' of the string
	data must be kept track of, because when the owner is deleted
	all references become invalid. If one tries to avoid the
	dangling reference problem by treating strings as value types,
	there will be a lot of overhead of memory allocation,
	data copying, and memory deallocation. Next, the 0-termination
	implies that strings cannot refer to other strings. String
	data in the data segment, stack, etc., cannot
	be referred to.
</p>

<p>	D strings are reference types, and the memory is garbage collected.
	This means that only references need to be copied, not the
	string data. D strings can refer to data in the static data
	segment, data on the stack, data inside other strings, objects,
	file buffers, etc. There's no need to keep track of the 'owner'
	of the string data.
</p>

<p>	The obvious question is if multiple D strings refer to the same
	string data, what happens if the data is modified? All the
	references will now point to the modified data. This can have
	its own consequences, which can be avoided if the copy-on-write
	convention is followed. All copy-on-write is is that if
	a string is written to, an actual copy of the string data is made
	first.
</p>

<p>	The result of D strings being reference only and garbage collected
	is that code that does a lot of string manipulating, such as
	an lzw compressor, can be a lot more efficient in terms of both
	memory consumption and speed.
</p>

<h2>Benchmark</h2>

<p>	Let's take a look at a small utility, wordcount, that counts up
	the frequency of each word in a text file. In D, it looks like this:
</p>

<pre class="d_code"><span class="d_keyword">import</span> file;

<span class="d_keyword">int</span> main (<span class="d_keyword">char</span>[][] args)
{
    <span class="d_keyword">int</span> w_total;
    <span class="d_keyword">int</span> l_total;
    <span class="d_keyword">int</span> c_total;
    <span class="d_keyword">int</span>[<span class="d_keyword">char</span>[]] dictionary;

    printf(<span class="d_string">"   lines   words   bytes file\n"</span>);
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 1; i &lt; args.length; ++i)
    {
	<span class="d_keyword">char</span>[] input;
	<span class="d_keyword">int</span> w_cnt, l_cnt, c_cnt;
	<span class="d_keyword">int</span> inword;
	<span class="d_keyword">int</span> wstart;

	input = <span class="d_keyword">cast</span>(<span class="d_keyword">char</span>[])file.read(args[i]);

	<span class="d_keyword">for</span> (<span class="d_keyword">int</span> j = 0; j &lt; input.length; j++)
	{   <span class="d_keyword">char</span> c;

	    c = input[j];
	    <span class="d_keyword">if</span> (c == '\n')
		++l_cnt;
	    <span class="d_keyword">if</span> (c &gt;= '0' &amp;&amp; c &lt;= '9')
	    {
	    }
	    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (c &gt;= 'a' &amp;&amp; c &lt;= 'z' ||
		c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
	    {
		<span class="d_keyword">if</span> (!inword)
		{
		    wstart = j;
		    inword = 1;
		    ++w_cnt;
		}
	    }
	    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (inword)
	    {   <span class="d_keyword">char</span>[] word = input[wstart .. j];

		dictionary[word]++;
		inword = 0;
	    }
	    ++c_cnt;
	}
	<span class="d_keyword">if</span> (inword)
	{   <span class="d_keyword">char</span>[] w = input[wstart .. input.length];
	    dictionary[w]++;
	}
	printf(<span class="d_string">"%8lu%8lu%8lu %.*s\n"</span>, l_cnt, w_cnt, c_cnt, args[i]);
	l_total += l_cnt;
	w_total += w_cnt;
	c_total += c_cnt;
    }

    <span class="d_keyword">if</span> (args.length &gt; 2)
    {
	printf(<span class="d_string">"--------------------------------------\n%8lu%8lu%8lu total"</span>,
	    l_total, w_total, c_total);
    }

    printf(<span class="d_string">"--------------------------------------\n"</span>);

    <span class="d_keyword">foreach</span> (<span class="d_keyword">char</span>[] word1; dictionary.keys.sort)
    {
	printf(<span class="d_string">"%3d %.*s\n"</span>, dictionary[word1], word1);
    }
    <span class="d_keyword">return</span> 0;
}
</pre>

	<p>(An <a href="wc.html">alternate implementation</a> that 
	uses buffered file I/O to handle larger files.)</p>

	<p>	Two people have written C++ implementations using the C++ standard
	template library,
	<a href="http://groups.google.com/groups?q=g:thl953709878d&amp;dq=&amp;hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;selm=bjacrl%244un%2401%241%40news.t-online.com">wccpp1</a>
	and
	<a href="#wccpp2">wccpp2</a>.
	The input file
	<a href="../../../../../../../../sailor.gutenberg.org/etext91/alice30.html">alice30.txt</a>
	is the text of "Alice in Wonderland."
	The D compiler,
	<a HREF="../../../../../../../../ftp.digitalmars.com/dmd.zip" title="download D compiler">dmd</a>,
	and the C++ compiler,
	<a HREF="../../../../../../../../ftp.digitalmars.com/dmc.zip" title="download dmc.zip">dmc</a>,
	share the same
	optimizer and code generator, which provides a more apples to
	apples comparison of the efficiency of the semantics of the languages
	rather than the optimization and code generator sophistication.
	Tests were run on a Win XP machine. dmc uses STLport for the template
	implementation.
	</p>

	<table border=1 cellpadding=4 cellspacing=0>	<tr>	<th>Program</th>
	<th>Compile</th>
	<th>Compile Time</th>
	<th>Run</th>
	<th>Run Time</th>
	</tr>
	<tr>	<td>D wc</td>
	<td>dmd wc -O -release</td>
	<td>0.0719</td>
	<td>wc alice30.txt &gt;log</td>
	<td>0.0326</td>
	</tr>
	<tr>	<td>C++ wccpp1</td>
	<td>dmc wccpp1 -o -I\dm\stlport\stlport</td>
	<td>2.1917</td>
	<td>wccpp1 alice30.txt &gt;log</td>
	<td>0.0944</td>
	</tr>
	<tr>	<td>C++ wccpp2</td>
	<td>dmc wccpp2 -o -I\dm\stlport\stlport</td>
	<td>2.0463</td>
	<td>wccpp2 alice30.txt &gt;log</td>
	<td>0.1012</td>
	</tr>
	</table>

	<p>	The following tests were run on linux, again comparing a D compiler
	(<a href="http://home.earthlink.net/~dvdfrdmn/d">gdc</a>)
	and a C++ compiler (<b>g++</b>) that share a common optimizer and
	code generator. The system is Pentium III 800MHz running RedHat Linux 8.0
	and gcc 3.4.2.
	The Digital Mars D compiler for linux (<b>dmd</b>)
	is included for comparison.
	</p>


	<table border=1 cellpadding=4 cellspacing=0>	<tr>	<th>Program</th>
	<th>Compile</th>
	<th>Compile Time</th>
	<th>Run</th>
	<th>Run Time</th>
	</tr>
	<tr>	<td>D wc</td>
	<td>gdc -O2 -frelease -o wc wc.d</td>
	<td>0.326</td>
	<td>wc alice30.txt &gt; /dev/null</td>
	<td>0.041</td>
	</tr>
	<tr>	<td>D wc</td>
	<td>dmd wc -O -release</td>
	<td>0.235</td>
	<td>wc alice30.txt &gt; /dev/null</td>
	<td>0.041</td>
	</tr>
	<tr>	<td>C++ wccpp1</td>
	<td>g++ -O2 -o wccpp1 wccpp1.cc</td>
	<td>2.874</td>
	<td>wccpp1 alice30.txt &gt; /dev/null</td>
	<td>0.086</td>
	</tr>
	<tr>	<td>C++ wccpp2</td>
	<td>g++ -O2 -o wccpp2 wccpp2.cc</td>
	<td>2.886</td>
	<td>wccpp2 alice30.txt &gt; /dev/null</td>
	<td>0.095</td>
	</tr>
	</table>

	<p>	These tests compare gdc with g++ on a PowerMac G5 2x2.0GHz
	running MacOS X 10.3.5 and gcc 3.4.2. (Timings are a little
	less accurate.)
	</p>

	<table border=1 cellpadding=4 cellspacing=0>	<tr>	<th>Program</th>
	<th>Compile</th>
	<th>Compile Time</th>
	<th>Run</th>
	<th>Run Time</th>
	</tr>
	<tr>	<td>D wc</td>
	<td>gdc -O2 -frelease -o wc wc.d</td>
	<td>0.28</td>
	<td>wc alice30.txt &gt; /dev/null</td>
	<td>0.03</td>
	</tr>
	<tr>	<td>C++ wccpp1</td>
	<td>g++ -O2 -o wccpp1 wccpp1.cc</td>
	<td>1.90</td>
	<td>wccpp1 alice30.txt &gt; /dev/null</td>
	<td>0.07</td>
	</tr>
	<tr>	<td>C++ wccpp2</td>
	<td>g++ -O2 -o wccpp2 wccpp2.cc</td>
	<td>1.88</td>
	<td>wccpp2 alice30.txt &gt; /dev/null</td>
	<td>0.08</td>
	</tr>
	</table>
<hr>
<h4><a name="wccpp2">wccpp2 by Allan Odgaard</a></h4>

<pre class="ccode">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

bool isWordStartChar (char c)	{ return isalpha(c); }
bool isWordEndChar (char c)	{ return !isalnum(c); }

int main (int argc, char const* argv[])
{
    using namespace std;
    printf("Lines Words Bytes File:\n");

    map&lt;string, int&gt; dict;
    int tLines = 0, tWords = 0, tBytes = 0;
    for(int i = 1; i &lt; argc; i++)
    {
	ifstream file(argv[i]);
	istreambuf_iterator&lt;char&gt; from(file.rdbuf()), to;
	vector&lt;char&gt; v(from, to);
	vector&lt;char&gt;::iterator first = v.begin(), last = v.end(), bow, eow;

	int numLines = count(first, last, '\n');
	int numWords = 0;
	int numBytes = last - first;

	for(eow = first; eow != last; )
	{
	    bow = find_if(eow, last, isWordStartChar);
	    eow = find_if(bow, last, isWordEndChar);
	    if(bow != eow)
		++dict[string(bow, eow)], ++numWords;
	}

	printf("%5d %5d %5d %s\n", numLines, numWords, numBytes, argv[i]);

	tLines += numLines;
	tWords += numWords;
	tBytes += numBytes;
    }

    if(argc &gt; 2)
	    printf("-----------------------\n%5d %5d %5d\n", tLines, tWords, tBytes);
    printf("-----------------------\n\n");

    for(map&lt;string, int&gt;::const_iterator it = dict.begin(); it != dict.end(); ++it)
	    printf("%5d %s\n", it-&gt;second, it-&gt;first.c_str());

    return 0;
}
</pre>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/CPPstrings" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/cppstrings.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:32:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>


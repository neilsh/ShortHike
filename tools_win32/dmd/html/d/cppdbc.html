
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/cppdbc.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:32:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - D's Contract Programming vs C++'s</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/CppDbc" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Tue Jun  6 16:38:19 2006
</div>
</div>

<!-- Generated by Ddoc from cppdbc.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="comparison.html">D vs C/C++/C#/Java</a></li>

	<li><a href="builtin.html">   Rationale for Builtins</a></li>

	<li><a href="ctod.html">      Converting C to D</a></li>

	<li><a href="cpptod.html">    Converting C++ to D</a></li>

	<li><a href="pretod.html">The C Preprocessor vs D</a></li>

	<li><a href="cppstrings.html">D strings vs C++ std::string</a></li>

	<li><a href="cppcomplex.html">D complex vs C++ std::complex</a></li>

	<li><a href="cppdbc.html">    D Contract Programming vs C++</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>D's Contract Programming vs C++'s</h1>
  
	Many people have written me saying that D's Contract Programming
	(DbC) does not add anything that C++ does not already support.
	They go on to illustrate their point with a technique for doing DbC in
	C++.
	<p>

	It makes sense to review what DbC is, how it is done in D,
	and stack that up with what each of the various C++ DbC techniques
	can do.
	<p>

	Digital Mars C++ adds
	<a href="../ctg/contract.html">extensions to C++</a>
	to support DbC, but they are not covered here because they are not
	part of standard C++ and are not supported by any other C++ compiler.

<h2>Contract Programming in D</h2>

	This is more fully documented in the D
	<a href="dbc.html">Contract Programming</a> document.
	To sum up, DbC in D has the following characteristics:

	<ol>

	<li> The <i>assert</i> is the basic contract.

	<li> When an assert contract fails, it throws an exception.
	Such exceptions can be caught and handled, or allowed to
	terminate the program.

	<li> Classes can have <i>class invariants</i> which are
	checked upon entry and exit of each public class member function,
	the exit of each constructor, and the entry of the destructor.

	<li> Assert contracts on object references check the class
	invariant for that object.

	<li> Class invariants are inherited, that means that a derived
	class invariant will implicitly call the base class invariant.

	<li> Functions can have <i>preconditions</i> and <i>postconditions</i>.

	<li> For member functions in a class inheritance hierarchy, the
	precondition of a derived class function are OR'd together
	with the preconditions of all the functions it overrides.
	The postconditions are AND'd together.

	<li> By throwing a compiler switch, DbC code can be enabled
	or can be withdrawn from the compiled code.

	<li> Code works semantically the same with or without DbC
	checking enabled.

	</ol>

<h2>Contract Programming in C++</h2>

<h3>The <tt>assert</tt> Macro</h3>

	C++ does have the basic <tt>assert</tt> macro, which tests its argument
	and if it fails, aborts the program. <tt>assert</tt> can be turned
	on and off with the <tt>NDEBUG</tt> macro.
	<p>

	<tt>assert</tt> does not know anything about class invariants,
	and does not throw an exception when it fails. It just aborts
	the program after writing a message. <tt>assert</tt> relies on
	a macro text preprocessor to work.
	<p>

	<tt>assert</tt> is where explicit support for DbC in Standard C++
	begins and ends.

<h3>Class Invariants</h3>

	Consider a class invariant in D:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <b><span class="d_keyword">invariant</span></b>() { ...contracts... }

    <span class="d_keyword">this</span>() { ... }	<span class="d_comment">// constructor
</span>    ~<span class="d_keyword">this</span>() { ... }	<span class="d_comment">// destructor
</span>
    <span class="d_keyword">void</span> foo() { ... }	<span class="d_comment">// public member function
</span>}

<span class="d_keyword">class</span> B : A
{
    <b><span class="d_keyword">invariant</span></b>() { ...contracts... }
    ...
}
</pre>

	To accomplish the equivalent in C++ (thanks to Bob Bell for providing
	this):

<pre class="ccode">template<typename T>
inline void check_invariant(T&amp; iX)
{
#ifdef DBC
    iX.invariant();
#endif
}

// A.h:

class A {
    public:
#ifdef DBG
       virtual void invariant() { ...contracts... }
#endif
       void foo();
};

// A.cpp:

void A::foo()
{
    check_invariant(*this);
    ...
    check_invariant(*this);
}

// B.h:

#include "A.h"

class B : public A {
    public:
#ifdef DBG
	virtual void invariant()
	{   ...contracts...
	   A::invariant();
	}
#endif
       void bar();
};

// B.cpp:

void B::barG()
{
    check_invariant(*this);
    ...
    check_invariant(*this);
}
</pre>

	There's an additional complication with <tt>A::foo()</tt>. Upon every
	normal exit from the function, the <tt>invariant()</tt> should be
	called.
	This means that code that looks like:

<pre class="ccode">int A::foo()
{
    ...
    if (...)
	return bar();
    return 3;
}
</pre>

	would need to be written as:

<pre class="ccode">int A::foo()
{
    int result;
    check_invariant(*this);
    ...
    if (...)
    {
	result = bar();
	check_invariant(*this);
	return result;
    }
    check_invariant(*this);
    return 3;
}
</pre>

	Or recode the function so it has a single exit point.
	One possibility to mitigate this is to use RAII techniques:

<pre class="ccode">int A::foo()
{
#if DBC
    struct Sentry {
       Sentry(A&amp; iA) : mA(iA) { check_invariants(iA); }
       ~Sentry() { check_invariants(mA); }
       A&amp; mA;
    } sentry(*this);
#endif
    ...
    if (...)
	return bar();
    return 3;
}
</pre>

	The #if DBC is still there because some compilers may not
	optimize the whole thing away if check_invariants compiles to nothing.

<h2>Preconditions and Postconditions</h2>

	Consider the following in D:

<pre class="d_code"><span class="d_keyword">void</span> foo()
    <span class="d_keyword">in</span> { ...preconditions... }
    <span class="d_keyword">out</span> { ...postconditions... }
    <span class="d_keyword">body</span>
    {
	...implementation...
    }
</pre>

	This is nicely handled in C++ with the nested Sentry struct:

<pre class="ccode">void foo()
{
    struct Sentry
    {   Sentry() { ...preconditions... }
	~Sentry() { ...postconditions... }
    } sentry;
    ...implementation...
}
</pre>

	If the preconditions and postconditions consist of nothing
	more than <tt>assert</tt> macros, the whole doesn't need to
	be wrapped in a <tt>#ifdef</tt> pair, since a good C++ compiler will
	optimize the whole thing away if the <tt>assert</tt>s are turned off.
	<p>

	But suppose <tt>foo()</tt> sorts an array, and the postcondition needs
	to walk the array and verify that it really is sorted. Now
	the shebang needs to be wrapped in <tt>#ifdef</tt>:

<pre class="ccode">void foo()
{
#ifdef DBC
    struct Sentry
    {   Sentry() { ...preconditions... }
	~Sentry() { ...postconditions... }
    } sentry;
#endif
    ...implementation...
}
</pre>

	(One can make use of the C++ rule that templates are only
	instantiated when used can be used to avoid the <tt>#ifdef</tt>, by
	putting the conditions into a template function referenced
	by the <tt>assert</tt>.)
	<p>

	Let's add a return value to <tt>foo()</tt> that needs to be checked in
	the postconditions. In D:

<pre class="d_code"><span class="d_keyword">int</span> foo()
    <span class="d_keyword">in</span> { ...preconditions... }
    <span class="d_keyword">out</span> (result) { ...postconditions... }
    <span class="d_keyword">body</span>
    {
	...implementation...
	<span class="d_keyword">if</span> (...)
	    <span class="d_keyword">return</span> bar();
	<span class="d_keyword">return</span> 3;
    }
</pre>

	In C++:

<pre class="ccode">int foo()
{
#ifdef DBC
    struct Sentry
    {   int result;
	Sentry() { ...preconditions... }
	~Sentry() { ...postconditions... }
    } sentry;
#endif
    ...implementation...
    if (...)
    {   int i = bar();
#ifdef DBC
	sentry.result = i;
#endif
	return i;
    }
#ifdef DBC
    sentry.result = 3;
#endif
    return 3;
}
</pre>

	Now add a couple parameters to <tt>foo()</tt>. In D:

<pre class="d_code"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
    <span class="d_keyword">in</span> { ...preconditions... }
    <span class="d_keyword">out</span> (result) { ...postconditions... }
    <span class="d_keyword">body</span>
    {
	...implementation...
	<span class="d_keyword">if</span> (...)
	    <span class="d_keyword">return</span> bar();
	<span class="d_keyword">return</span> 3;
    }
</pre>

	In C++:

<pre class="ccode">int foo(int a, int b)
{
#ifdef DBC
    struct Sentry
    {   int a, b;
	int result;
	Sentry(int a, int b)
	{   this-&gt;a = a;
	    this-&gt;b = b;
	    ...preconditions...
	}
	~Sentry() { ...postconditions... }
    } sentry(a,b);
#endif
    ...implementation...
	if (...)
	{   int i = bar();
#ifdef DBC
	    sentry.result = i;
#endif
	    return i;
	}
#ifdef DBC
	sentry.result = 3;
#endif
	return 3;
}
</pre>

<h2>Preconditions and Postconditions for Member Functions</h2>

	Consider the use of preconditions and postconditions for a
	polymorphic function in D:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">void</span> foo()
	<span class="d_keyword">in</span> { ...Apreconditions... }
	<span class="d_keyword">out</span> { ...Apostconditions... }
	<span class="d_keyword">body</span>
	{
	    ...implementation...
	}
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">void</span> foo()
	<span class="d_keyword">in</span> { ...Bpreconditions... }
	<span class="d_keyword">out</span> { ...Bpostconditions... }
	<span class="d_keyword">body</span>
	{
	    ...implementation...
	}
}
</pre>

	The semantics for a call to <tt>B.foo()</tt> are:

	<ul>
	<li> Either Apreconditions or Bpreconditions must be satisfied.
	<li> Both Apostconditions and Bpostconditions must be satisfied.
	</ul>

	Let's get this to work in C++:

<pre class="ccode">class A
{
protected:
    #if DBC
    int foo_preconditions() { ...Apreconditions... }
    void foo_postconditions() { ...Apostconditions... }
    #else
    int foo_preconditions() { return 1; }
    void foo_postconditions() { }
    #endif

    void foo_internal()
    {
	...implementation...
    }

public:
    virtual void foo()
    {
	foo_preconditions();
	foo_internal();
	foo_postconditions();
    }
};

class B : A
{
protected:
    #if DBC
    int foo_preconditions() { ...Bpreconditions... }
    void foo_postconditions() { ...Bpostconditions... }
    #else
    int foo_preconditions() { return 1; }
    void foo_postconditions() { }
    #endif

    void foo_internal()
    {
	...implementation...
    }

public:
    virtual void foo()
    {
	assert(foo_preconditions() || A::foo_preconditions());
	foo_internal();
	A::foo_postconditions();
	foo_postconditions();
    }
};
</pre>

	Something interesting has happened here. The preconditions can
	no longer be done using <tt>assert</tt>, since the results need
	to be OR'd together. I'll leave as a reader exercise adding
	in a class invariant, function return values for <tt>foo()</tt>,
	and parameters
	for <tt>foo()</tt>.

<h2>Conclusion</h2>

	These C++ techniques can work up to a point. But, aside from
	<tt>assert</tt>, they are not standardized and so will vary from
	project to project. Furthermore, they require much tedious
	adhesion to a particular convention, and add significant clutter
	to the code. Perhaps that's why it's rarely seen in practice.
	<p>

	By adding support for DbC into the language, D offers an easy
	way to use DbC and get it right. Being in the language standardizes
	the way it will be used from project to project.

<h2>References</h2>

	Chapter C.11 introduces the theory and rationale of
	Contract Programming in
	<a href="http://www.amazon.com/exec/obidos/ASIN/0136291554/classicempire">
	Object-Oriented Software Construction
	</a><br>
	Bertrand Meyer, Prentice Hall
	<p>

	Chapters 24.3.7.1 to 24.3.7.3 discuss Contract Programming in C++ in
	<a href="http://www.amazon.com/exec/obidos/ASIN/0201700735/classicempire">
	The C++ Programming Language Special Edition
	</a><br>
	Bjarne Stroustrup, Addison-Wesley
	<p>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/CppDbc" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/cppdbc.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:32:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

